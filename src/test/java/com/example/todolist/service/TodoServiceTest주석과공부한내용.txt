package com.example.todolist.service;

import com.example.todolist.dto.TodoRequestDto;
import com.example.todolist.dto.TodoResponseDto;
import com.example.todolist.model.Todo;
import com.example.todolist.repository.TodoRepository;
import jakarta.persistence.EntityNotFoundException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
// → Mockito 확장을 적용해 @Mock, @InjectMocks 어노테이션을 사용할 수 있게 해줌
class TodoServiceTest {

    @Mock
    private TodoRepository todoRepository;
    // → 실제 DB 접근 대신 가짜 객체(Mock) 생성

    @InjectMocks
    private TodoService todoService;
    // → @Mock으로 만든 todoRepository를 주입받은 todoService 생성

    @Test
    @DisplayName("새로운 Todo를 생성하면 저장된 Todo 정보를 반환한다.")
    void createTodo() {
        // given: 테스트 준비
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("새로운 할 일"); // 사용자가 전달한 요청 DTO

        Todo todo = new Todo("새로운 할 일"); // 저장될 엔티티
        given(todoRepository.save(any(Todo.class))).willReturn(todo);
        // save() 호출 시 todo 반환하도록 Stubbing

        // when: 실제 서비스 메서드 실행
        TodoResponseDto responseDto = todoService.createTodo(requestDto);

        // then: 결과 검증
        assertThat(responseDto.getTitle()).isEqualTo("새로운 할 일");
    }

    @Test
    @DisplayName("존재하는 ID로 Todo를 업데이트하면 수정된 내용이 반영된다.")
    void updateTodo() {
        // given
        Long id = 1L;
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("수정된 할 일"); // 수정할 제목

        Todo existingTodo = new Todo("원래 할 일"); // DB에 있던 기존 Todo
        given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));
        // findById() 호출 시 기존 Todo 반환

        // when
        TodoResponseDto responseDto = todoService.updateTodo(id, requestDto);

        // then
        assertThat(responseDto.getTitle()).isEqualTo("수정된 할 일");
    }

    @Test
    @DisplayName("존재하지 않는 ID로 Todo를 업데이트하면 예외가 발생한다.")
    void updateTodo_throwsException() {
        // given
        Long id = 99L; // 존재하지 않는 ID
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("수정된 할 일");
        given(todoRepository.findById(id)).willReturn(Optional.empty());
        // DB에 없는 경우 → Optional.empty() 반환하도록 Stubbing

        // when & then: 예외 검증
        assertThrows(EntityNotFoundException.class, () -> {
            todoService.updateTodo(id, requestDto);
        });
    }

    @Test
    @DisplayName("Todo의 완료 상태를 토글할 수 있다.")
    void toggleTodo() {
        // given
        Long id = 1L;
        Todo todo = new Todo("할 일");
        assertThat(todo.getCompleted()).isFalse();
        // 초기 상태는 미완료(false)

        given(todoRepository.findById(id)).willReturn(Optional.of(todo));
        // findById() 호출 시 Todo 반환

        // when
        TodoResponseDto responseDto = todoService.toggleTodo(id);

        // then
        assertThat(responseDto.getCompleted()).isTrue();
        // 완료 상태로 변경됐는지 확인
    }

    @Test
    @DisplayName("존재하는 ID의 Todo를 삭제할 수 있다.")
    void deleteTodo() {
        // given
        Long id = 1L;
        given(todoRepository.existsById(id)).willReturn(true);
        // 삭제 대상이 존재한다고 가정

        // when
        todoService.deleteTodo(id);

        // then
        verify(todoRepository).deleteById(id);
        // deleteById() 메서드가 호출됐는지 검증
    }
}



@InjectionMocks 뜻
@InjectionMocks 는  Mockito 가 Mock 객체들을 주입해줘서 실제 테스트할 대상 객체를 만들어주는 애너테이션입니다

@InjectMocks
이 클래스는 진짜 객체를 만들어주는데, 내부에 필요한 의존성은 Mock으로 자동주입해 줄게  라는 의미


@Mock
private TodoRespository todoRepository;

@InjectMocks
private TodoService todoService;

1. @Mock -> todoRepository 는 가짜 객체(Mock)
2. @InjectMocks -> TodosService 객체(todoService)를 만들 때,
생성자나 필드에 Mock 객체(todoRepoistory)를 자도응로 넣어줌

TodoService가 내부적으로 TodoRepository를 필요로함
Mockito 가 todoService를 만들고, @Mock으로 만든 todoRepository를 거기에 자동으로 주입해줌
따라서 실제 DB를 사용하지 않고도 todoService의 동작을 테스트할 수 있음



@Test
@DisplayName("존재하는 ID로 Todo를 업데이트하면 수정된 내용이 반영된다.")
// 테스트 이름을 보기 쉽게 지정 -> 실행 시 존재하는 ID로 Todo를 업데이트하면 수정된 내용이 반영된다." 로 표시됨

void updateTodo() {
    // given: 테스트 준비 단계
    Long id = 1L;
    // 업데이트할 Todo의 가짜 ID

    TodoRequestDto requestDto = new TodoRequestDto();
    requestDto.setTitle("수정된 할 일");
    // 클라이언트가 보낸 요청처럼, 수정할 제목을 담은 DTO 준비

    Todo existingTodo = new Todo("원래 할 일");
    // DB에 이미 저장되어 있던 기존 Todo를 가정
    given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));
    // todoRepository.findById(1L) 호출 시 -> 기존 Todo 반환하도록 Mock 설정

    // when: 실제 테스트 대상 메서드 실행
    TodoResponseDto responseDto = todoService.updateTodo(id, requestDto);
    // 서비스의 updateTodo 호출
    // 내부에서는 findById -> 기존 Todo 찾기 -> 제목 수정 -> Dto 변환 흐름이 실행됨

    // then : 검증 단계
    assertThat(responseDto.getTitle()).isEqualTo("수정된 할 일");
    // 반한된 DTO 제목이 수정된 값("수정된 할 일")인지 확인
}




given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));

given(...)
Mockito(테스트 용 라이브러리)에서 사용하는 BDD 스타일의 메서드
"만약 ~라면"   이라는 조건을 정의하는 역할을 한다

todoRepository.findById(id)
todoRepository 에서 특정 id 값으로 할 일 (Todo)을 조회하는 메서드 호출
(원래는 DB에서 찾아야 하는데, 테스트에서는 진짜 DB를 쓰지 않고 가짜 동작을 설정함)

.willReturn
이 메서드가 실행되면 이런 값을 돌려줘라    라고 지정한 부분이다

Optional.of(existingTodo)
existingTodo 라는 미리 준비한 가짜 Todo 객체를 Optional 로 감싸서 반환하도록 함

전체문장의 의미
만약 todoRepository.findById(id)가 호출되면, 실제 DB를 뒤지지 않고 existingTodo를 담은 Otional 객체를 반환하도록 설정한다

즉, 테스트 코드에서 DB대신 원하는 값을 돌려주게 만드는 가짜 시뮬레이션 설정이다.


Optional.of(existingTodo)
Optional 이란?
Optional<T> 는 java8에서 도입된 null일 수도 있는 값을 안전하게 다루는 객체
값이 있을 수도 있고(present), 없을 수도 있음(empty)
NullPointerException을 피하려고 쓰는 일종의 포장(wrapper)

Optional.of(existingTodo)
Optional.of(...)
전달한 객체를 Optional로 감싸서 반환

즉, existingTodo가 반드시 null이 아님을 보장할 때 사용
existingTodo가 null 이면 NullPointerException 발생

-> existingTodo 객체를 Optional 이라는 안전한 박스에 넣어서 감싸 반환한다.



given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));

1. given
Mockito의 BDD 스타일 메서드
만약~ 가 호출되면  이라는 조건을 설정하는 부분

todoRepository.findById(id)
todoRepository 에서 특정 id 값으로 Todo 객체를 찾는 메서드 호출
원래는 DB에 접근해야 하지만, 테스트에서는 DB를 쓰지 않고 가짜 동작을 정의한다

.willReturn(...)
앞에서 지정한 메서드가 실행되면 이 값을 돌려줘라   라는 의미

Optional.of(existingTodo)
existingTodo 라는 미리 준비된 가짜 Todo 객체를 Optional 로 감싸서 반환
즉, DB 에서 찾은 것처럼 행동하게 만듦


given(todoRepository.findById(id).willReturn(optional.of(existingTodo));
->
만약 todoRepository.findById(id) 가 호출되면, 실제 DB 조회 대신 existingTodo 객체가 담긴 Optional 을 반환하라

테스트 환경에서 리포지토리의 동작을 가짜로 시뮬레이션(mocking) 한 것입니다.


@Test
@DisplayName("존재하는 ID로 Todo를 업데이트하면 수정된 내용이 반영된다.")
void updateTodo() {
    // given
    Long id = 1L;
    TodoRequestDto requestDto = new TodoRequestDto();
    requestDto.setTitle("수정된 할 일");

    Todo existingTodo = new Todo("원래 할 일");
    given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));

    // when
    TodoResponseDto responseDto = todoService.updateTodo(id, requestDto);

    // then
    assertThat(responseDto.getTitle()).isEqualTo("수정된 할 일");
}

동작원리
1. given (테스트 준비 단계)
id = 1L 업데이트할 Todo의 Id

requestDto
새 제목 "수정된 할 일"이 담긴 요청 DTO 생성

existingTodo
원래 DB에 있다고 가정한 "원래 할 일" 객체 생성

given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));
DB에서 id = 1 을 조회하면 실제 DB대신 existingTodo 객체를 돌려주도록 설정

즉,
DB 조회 동작을 가짜로 시뮬레이션(mocking)


2. when (실행 단계)
TodoResponseDto responseDto = todoService.updateTodo(id, requestDto);

서비스 계층(todoService)의 updateTodo 메서드 호출

내부 동작 (일반적인 update 흐름)
1. todoRepository.findById(id) 실행 -> existingTodo 반환
2. existingTodo의 제목을 requestDto의 "수정된 할 일"로 변경
3. 변경된 existingTodo를 저장(save) 호출
4. 최종적으로 수정된 Todo를 응답 DTO(TodoResponseDto)로 변환 후 반환


3. then(검증 단계)
assertThat(responseDto.getTitle()).isEqualTo("수정된 할일");
responseDto 안에 들어 있는 제목이 "수정된 할 일 " 인지 검증
즉, 수정 로직이 잘 반영되었는지 확인



given(todoRepository.findById(id)).willReturn(Optional.empty());
해석해줘


.willReturn(Optional.empty())
willReturn(...) 이 호출이 발생하면 이 값을 반환하라

Optional.empty() 아무 값도 담겨 있지 않은 빈 Optional을 반환
즉, DB에서 해당 id로 찾았는데 존재하지 않는다(null 같은 의미)

전체의미
만약 todoRepository.findById(id) 가 호출되면, Todo가 존재 하지 않는 것처럼 빈 Optional을 반환하라

이 경우 테스트에서는 주로
존재 하지 않는 id로 업데이트/ 조회하면 예외가 발생해야 한다
즉, 예외처리 로직을 검증할 때 사용

assertThrows(EntityNotFoundException.class () -> { )

assertThrows(...)
JUnit의 예외 검증 메서드
이 코드 블록을 실행했을 때 특정 예외가 발생해야 한다   를 확인할 때 사용.


EntityNotFoundException.class
기대하는 예외 타입
여기서는 EntityNotFoundException 이 발생해야 테스트가 통과함
즉, 존재 하지 않는 엔티티(ID로 찾을 수 없는 Todo)를 조회하거나 수정하려 할 때 던져지는 예외   를 검증

()-> {...}
람다 표현식
이 블록 안에 실제로 예외가 발생해야 할 코드를 넣음
예: todoService.updateTodo(id, requestDto) 같은 호출

해석
이 블록 안 코드를 실행했을 때 EntityNotFoundException 이 발생해야 한다.


asserThrows(EntityNotFoundException.class, () -> {
    todoService.updateTodo(id, requestDto);
});

즉, "존재 하지 않는 ID로 업데이트를 시도하면 EntityNotFoundException"이 발생해야 한다는 걸 검증하는 테스트




@Test
@DisplayName("존재하지 않는 ID로 Todo를 업데이트하면 예외가 발생한다.")
void updateTodo_throwsException() {
    // given: 테스트 준비 단계

    Long id = 99L;
    // 존재하지 않는 Todo의 ID

    TodoRequestDto requestDto = new TodoRequestDto();
    // 수정 요청 DTO 생성
    requestDto.setTitle("수정된 할 일"); // 요청 DTO에 새로운 제목 설정

    // todoRepository.findById(99L)를 호출하면 DB에서 찾지 못한 것처럼 빈 Optional 을 반환하도록 mocking
    given(todoRepository.findById(id)).willReturn(Optional.empty());

    // when then  실행과 검증을 동시에
    // todoService.updateTodo 실행 시, 존재 하지 않는 ID이므로 EntityNotFoundException  예외가 발생해야 한다
    assertThrows(EntityNotFoundException.class () -> {
        todoService.updateTodo(id, requestDto);
    });
}


assertThrows(...)
예외가 발생하는지 확인하는 테스트 메서드입니다.
첫번째 인자로 "기대하는 예외 클래스"를 넘깁니다

EntityNotFoundException.class
테스트 중 EntityNotFoundException 이 반드시 발생해야 한다는 뜻입니다.

() -> { todoSErvice.updateTodo(id, requestDto);
실제 실행할 코드 (람다 표현식)
여기서는 todoService.updateTodo(id, requestDto) 실행 시 예외가 발생해야 합니다.

todoService.updateTodo(id, requestDto) 를 실행했을 때
EntityNotFoundException 이 발생해야한다
라는 걸 검증하는 코드입니다.

즉, 해당 id의 할 일이 없을 때 업데이트를 시도하면 EntityNotFoundException 이 터지는 지 확인하는 예외 처리 테스트



assertThrows
JUnit(테스트 프레임워크)에서 제공하는 메서드
"이 코드가 실행될 때 특정 예외가 발생해야 한다" 라고 확인(검증)하는 용도입니다.
만약 예외가 발생하지 않거나, 다른 예외가 발생하면 테스트 실패가 됩니다.


EntityNotFoundException.class
EntityNotFoundException -> 예외 클래스 (클래스 이름)
.class  그 클래스의 클래스 객체(메타 정보)를 뜻합니다

즉 EntityNotFoundException.class 는
JPA 에서 자주 쓰는 예외 클래스
데이터베이스에서 원하는 엔티티(레코드)를 못 찾았을 때 발생합니다.

todo라는 데이터를 id로 찾았는데 DB에 없으면 EntityNotFoundException 발생

.class
자바에서 클래스의 메타정보 (클래스 객체)를 가져오는 키워드

String.class
Integer.class

assertThrows 예외 발생을 테스트하는 메서드
EntityNotFoundException.class 이 예외 클래스 타입을 가리킴
EntityNotFoundException 데이터를 못찾았을 때 발생하는 예외
.class 클래스의 정보를 가리키는 키워드

id와 requestDto 로 todoService.updateTodo를 실행했을 때 EntityNotFoundException 이 반드시 발생해야 한다
라는 걸 검증하는 테스트코드

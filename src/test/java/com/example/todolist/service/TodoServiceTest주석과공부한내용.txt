package com.example.todolist.service;

import com.example.todolist.dto.TodoRequestDto;
import com.example.todolist.dto.TodoResponseDto;
import com.example.todolist.model.Todo;
import com.example.todolist.repository.TodoRepository;
import jakarta.persistence.EntityNotFoundException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
// → Mockito 확장을 적용해 @Mock, @InjectMocks 어노테이션을 사용할 수 있게 해줌
class TodoServiceTest {

    @Mock
    private TodoRepository todoRepository;
    // → 실제 DB 접근 대신 가짜 객체(Mock) 생성

    @InjectMocks
    private TodoService todoService;
    // → @Mock으로 만든 todoRepository를 주입받은 todoService 생성

    @Test
    @DisplayName("새로운 Todo를 생성하면 저장된 Todo 정보를 반환한다.")
    void createTodo() {
        // given: 테스트 준비
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("새로운 할 일"); // 사용자가 전달한 요청 DTO

        Todo todo = new Todo("새로운 할 일"); // 저장될 엔티티
        given(todoRepository.save(any(Todo.class))).willReturn(todo);
        // save() 호출 시 todo 반환하도록 Stubbing

        // when: 실제 서비스 메서드 실행
        TodoResponseDto responseDto = todoService.createTodo(requestDto);

        // then: 결과 검증
        assertThat(responseDto.getTitle()).isEqualTo("새로운 할 일");
    }

    @Test
    @DisplayName("존재하는 ID로 Todo를 업데이트하면 수정된 내용이 반영된다.")
    void updateTodo() {
        // given
        Long id = 1L;
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("수정된 할 일"); // 수정할 제목

        Todo existingTodo = new Todo("원래 할 일"); // DB에 있던 기존 Todo
        given(todoRepository.findById(id)).willReturn(Optional.of(existingTodo));
        // findById() 호출 시 기존 Todo 반환

        // when
        TodoResponseDto responseDto = todoService.updateTodo(id, requestDto);

        // then
        assertThat(responseDto.getTitle()).isEqualTo("수정된 할 일");
    }

    @Test
    @DisplayName("존재하지 않는 ID로 Todo를 업데이트하면 예외가 발생한다.")
    void updateTodo_throwsException() {
        // given
        Long id = 99L; // 존재하지 않는 ID
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("수정된 할 일");
        given(todoRepository.findById(id)).willReturn(Optional.empty());
        // DB에 없는 경우 → Optional.empty() 반환하도록 Stubbing

        // when & then: 예외 검증
        assertThrows(EntityNotFoundException.class, () -> {
            todoService.updateTodo(id, requestDto);
        });
    }

    @Test
    @DisplayName("Todo의 완료 상태를 토글할 수 있다.")
    void toggleTodo() {
        // given
        Long id = 1L;
        Todo todo = new Todo("할 일");
        assertThat(todo.getCompleted()).isFalse();
        // 초기 상태는 미완료(false)

        given(todoRepository.findById(id)).willReturn(Optional.of(todo));
        // findById() 호출 시 Todo 반환

        // when
        TodoResponseDto responseDto = todoService.toggleTodo(id);

        // then
        assertThat(responseDto.getCompleted()).isTrue();
        // 완료 상태로 변경됐는지 확인
    }

    @Test
    @DisplayName("존재하는 ID의 Todo를 삭제할 수 있다.")
    void deleteTodo() {
        // given
        Long id = 1L;
        given(todoRepository.existsById(id)).willReturn(true);
        // 삭제 대상이 존재한다고 가정

        // when
        todoService.deleteTodo(id);

        // then
        verify(todoRepository).deleteById(id);
        // deleteById() 메서드가 호출됐는지 검증
    }
}



@InjectionMocks 뜻
@InjectionMocks 는  Mockito 가 Mock 객체들을 주입해줘서 실제 테스트할 대상 객체를 만들어주는 애너테이션입니다

@InjectMocks
이 클래스는 진짜 객체를 만들어주는데, 내부에 필요한 의존성은 Mock으로 자동주입해 줄게  라는 의미


@Mock
private TodoRespository todoRepository;

@InjectMocks
private TodoService todoService;

1. @Mock -> todoRepository 는 가짜 객체(Mock)
2. @InjectMocks -> TodosService 객체(todoService)를 만들 때,
생성자나 필드에 Mock 객체(todoRepoistory)를 자도응로 넣어줌

TodoService가 내부적으로 TodoRepository를 필요로함
Mockito 가 todoService를 만들고, @Mock으로 만든 todoRepository를 거기에 자동으로 주입해줌
따라서 실제 DB를 사용하지 않고도 todoService의 동작을 테스트할 수 있음




package com.example.todolist.controller;

import com.example.todolist.dto.TodoRequestDto;
import com.example.todolist.dto.TodoResponseDto;
import com.example.todolist.model.Todo;
import com.example.todolist.service.TodoService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * TodoController를 테스트하는 단위 테스트 클래스
 *
 * - @WebMvcTest : Spring MVC 컴포넌트(Controller)만 로드하여 테스트
 * - MockMvc : 실제 서버 실행 없이 가상의 HTTP 요청/응답을 수행하는 도구
 * - @MockBean : Service 계층을 가짜(Mock) 객체로 주입해 Controller만 집중적으로 검증 가능
 */
@WebMvcTest(TodoController.class)
class TodoControllerTest {

    @Autowired
    private MockMvc mockMvc; // 가짜 HTTP 요청/응답을 수행하는 객체

    @MockBean
    private TodoService todoService; // 실제 서비스 대신 Mock 객체로 대체

    @Autowired
    private ObjectMapper objectMapper; // 객체 <-> JSON 직렬화/역직렬화 도와주는 Jackson 라이브러리

    @Test
    @DisplayName("새로운 Todo를 생성하는 API 호출이 성공한다.")
    void createTodo() throws Exception {
        // given : 테스트 준비 단계
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("API 테스트"); // 클라이언트에서 요청할 값

        // 서비스 계층이 호출될 때 어떤 응답을 줄지 미리 지정 (Mock 동작 정의)
        Todo savedTodo = new Todo("API 테스트");
        given(todoService.createTodo(any(TodoRequestDto.class)))
                .willReturn(new TodoResponseDto(savedTodo));

        // when : API 요청 수행
        ResultActions resultActions = mockMvc.perform(
                post("/api/todos") // POST /api/todos 요청
                        .contentType(MediaType.APPLICATION_JSON) // 요청 본문 타입 지정 (JSON)
                        .content(objectMapper.writeValueAsString(requestDto)) // 객체 → JSON 문자열 변환
        );

        // then : 응답 검증
        resultActions.andExpect(status().isOk()) // HTTP 상태코드 200 OK 예상
                .andExpect(jsonPath("$.title").value("API 테스트")) // 응답 JSON에 title 값이 "API 테스트"인지 확인
                .andDo(print()); // 요청/응답 로그 출력
    }

    @Test
    @DisplayName("Todo 내용을 수정하는 API 호출이 성공한다.")
    void updateTodo() throws Exception {
        // given
        Long id = 1L;
        TodoRequestDto requestDto = new TodoRequestDto();
        requestDto.setTitle("수정된 API 테스트"); // 수정 요청 값

        // 서비스 계층의 updateTodo 메서드가 호출되면 특정 응답을 리턴하도록 지정
        Todo updatedTodo = new Todo("수정된 API 테스트");
        given(todoService.updateTodo(eq(id), any(TodoRequestDto.class)))
                .willReturn(new TodoResponseDto(updatedTodo));

        // when : PUT 요청 수행
        ResultActions resultActions = mockMvc.perform(
                put("/api/todos/{id}", id) // 경로 변수 {id}에 1L 대입
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto))
        );

        // then : 응답 검증
        resultActions.andExpect(status().isOk()) // 상태코드 200 OK 예상
                .andExpect(jsonPath("$.title").value("수정된 API 테스트")) // 응답 title 값 확인
                .andDo(print()); // 요청/응답 로그 출력
    }
}


해설
1. 테스트 환경
@WebMvcTest
Controller 만 로드, Service는 @Mockbean으로 대체

MockMvc
실제 서버 실행 없이 HTTP 요청/응답 시뮬레이션 가능

2. Mock 동작 지정
given(todoService.createTodo(...))...willReturn(...)
-> Service 계층이 호출될 때, 실제 DB를 거치지 않고 미리 지정한 응답을 리턴하게 만듦

3. 테스트 흐름
given : 입력값/Mock 동작 설정
when: API 호출 수행 (mockMvc.perform)
then: 응답 검증 (status, jsonPath 사용)



@WebMvcTest
Spring MVC와 관련된 컨트롤러 계층만 로드해서 테스트하겠다는 뜻
즉, @Service, @Repository 같은 비즈니스 로직, DB연동 Bean들은 불러오지 않음
웹 계층(Controller, ControllerAdvice, Json 관련 Bean 등)만 최소한으로 띄우기 때문에 테스트가 빠르고 가볍습니다.

(TodoController.class)
특정 컨트롤러 클래스만 대상으로 테스트하겠다는 설정
만약 생략하면 프로젝트 내 모든 @Controller, @RestController 가 로드됩니다.
여기서는 TodoController 만 로드해서, 이 컨트롤러의 API를 집중적으로 테스트하는것입니다.


정리
@WebMvcTest(TodoController.class)
Spring MVC 테스트 환경을 구성하고, 그 중에서도 TodoController만 로드해서 테스트하겠다라는 뜻
따라서 TodoService 같은 의존성은 직접 로드되지 않고, @MockBean을 이용해서 가짜 객체를 주입해주어야한다



@Autowired
@Autowired는 스프링이 제공하는 의존성 주입(Dependency Injection, DI) 어노테이션입니다

@Autowired가 붙은 필드, 생성자, 메서드 파라미터에
스프링 컨테이너(applicationContext)가 관리하는 빈(Bean, 객체)을 자동으로 찾아서 주입해 줍니다.

즉, 개발자가 new로 직접 객체를 생성하지 않아도, 스프링이 알아서 필요한 객체를 넣어주는것이다


예시
java

@Autowired
private MockMvc mockMvc;

MockMvc 라는 객체를 스프링이 자동으로 만들어두고 있으니, 여기 변수에 자동으로 꽂아줍니다
테스트 실행 시 개발자가 따로 new MockMvc()를 할 필요가 없습니다.
(MockMvc 라는 객체를 내가 직접 new Mock() 해서 만드는게 아니라,
스프링이 테스트 환경을 만들 때 자동으로 필요한 Mock 객체를 만들어서 준비해 둡니다.

@Autowired를 붙여두면
스프링이 준비해 둔 그 MockMvc 객체를 찾아서 mockMvc 변수 안에 자동으로 넣어주는 것
)

@Autowired
private ObjectMapper objectMapper;

JSON 직렬화/ 역직렬화를 도와주는 ObjectMaaper도 스프링이 빈으로 관리 중이니 그냥 가져다 씁니다.

정리
@Autowired
스프링아, 이 타입에 맞는 객체를 찾아서 알아서 넣어줘 라는 뜻
따라서 객체 생성/ 관리 책임을 개발자가 아닌 스프링이 담당하게 됩니다.


private MockMvc mockMvc;

private
접근 제한자로, 이 변수를 해당 클래스 내부에서만 사용 가능하게 만듭니다.
(다른 클래스에서는 직접 접근할 수 없습니다.)

MockMvc
스프링에서 제공하는 테스트용 객체 타입
실제로 서버를 띄우지 않고도, 가짜로 HTTP 요청/ 응답을 흉내낼 수 있게 해줍니다.

예 :
mockMvc.perform(post("/api/todos"))

마치 클라이언트가 post 요청을 보낸 것처럼 테스트 가능

mockMvc
변수 이름. 보통 클래스 타입 이름의 첫 글자를 소문자로 해서 짓습니다.
즉, MockMvc 타입의 객체를 담아둘 변수라는 뜻입니다.

정리
private MockMvc mockMvc;
이 클래스 안에서만 쓸 수 있는 MockMvc 타입의 변수 mockMvc를 선언한 것
테스트할 때, 이 mockMvc를 이용해서 API요청을 보내고 응답을 확인합니다.



@MockBean은
스프링 테스트 환경에서 가짜(Mock) 객체를 만들어서 스프링 빈(Bean)으로 등록하는 어노테이션입니다.

즉, 테스트할 때 진짜 객체 대신    가짜 객체(모킹된 객체)를 넣어줍니다.

왜 쓸까?
@WebMvcTest 같은 컨트롤러 테스트에서는 서비스나 리포지토리 계층을 로드하지 않습니다.
그런데 컨트롤러는 보통 Service를 의존합니다

@RestController
public class TodoController {
    private final TodoService todoService;
    ...
}

만약 TodoService 빈이 없다면 컨트롤러를 실행할 수가 없습니다.
그래서 테스트할 때 진짜 TodoService를 불러오는 대신,

@MockBean으로 가짜 TodoService를 만들어서 주입해준다


@MockBean
private TodoService todoService;

이렇게 하면 todoService 라는 가짜(Mock) 서비스 객체가 스프링 컨테이너에 등록됩니다.
컨트롤러는 이 todoService 를 주입받아서 실행됩니다.
테스트할 때는 원하는 동작을 미리 지정할 수 있습니다.

예시
given(todoService.createTodo(any(TodoRequestDto.class)))
    .willReturn(new TodoResponseDto(new Todo("API 테스트")));

    즉, "createTodo 가 불리면 무조건 이 결과를 돌려줘" 라고 가짜 행동을 정의합니다.


@MockBean
진짜 대신 가짜 객체를 스프링 컨테이너에 등록해줘 라는 뜻
덕분에 테스트에서는 DB연결이나 복잡한 로직 없이 원하는 대로 동작을 흉내낼 수 있음



@Autowired
private ObjectMapper objectMapper;

@Autowired
스프링이 자동으로 객체를 찾아서 objectMapper 변수에 넣어줍니다.
개발자가 new ObjectMapper() 하지 않아도 됨

private
이 변수는 이 클래스 안에서만 사용 가능

ObjectMapper
Jackson 라이브러리에서 제공하는 클래스
역할: 자바 객체 <-> json 문자열 변환 담당
객체 -> JSON (writeValueAsString)
JSON -> 객체 (readValue)

objectMapper
변수 이름. 스프링이 준비해준 ObjectMapper 객체를 여기 담아서 씀

정리
이 클래스 안에서만 쓸 수 있는, 스프링이 자동으로 넣어주는 JSON 변환 도구(ObjectMapper) 변수



@Test
이 메서드는 테스트로 실행해야 한다  라고 JUnit에게 알려주는 표시


@DisplayName("새로운 Todo를 생성하는 API 호출이 성공한다")

이 부분은 테스트 코드에서 테스트 이름 (설명)을 붙여주는 어노테이션

@DisplayName("새로운 Todo를 생성하는 API 호출이 성공한다")
JUnit(=Jupiter)에서 제공하는 어노테이션
테스트 메서드나 클래스 위에 붙여서 사람이 읽기 좋은 이름(설명)을 붙여줍니다
테스트 실행할 때 IDE(JUnit 콘솔, IntelliJ, Eclipse 등)에 이 글자가 그대로 표시됩니다



void createTodo() throws Exception {
}

void 메서드의 리턴타입
void는 아무 값도 반환하지 않는다 는 뜻
즉, 이 메서드는 실행만 하지, 결과값을 돌려주지 않는다는 뜻
(테스트 메서드에서는 보통 void 를 많이 씀)

createTodo
메서드 이름
Todo를 생성하는 동작을 테스트하는 메서드   라는 의미로 이름을 붙인 것

()
메서드에 전달할 매개변수(parameter)가 없다는 뜻

throws Exception
이 메서드 안에서 예외(Exception)가 발생할 수 있고,
그 예외를 메서드 밖으로 던져(catch 하지 않고 전달) 줄 수 있다는 뜻
즉, 이 메서드를 호출한 쪽에서 예외를 처리해야 합니다

{...}
중괄호 안에 메서드의 실행 내용(구현부)이 들어갑니다



// given
TodoRequestDto requestDto = new TodoRequestDto();

// given
보통 테스트 코드(JUnit)에서
Given - When - Then 패턴을 따라 씁니다.

Given
테스트를 위해 준비하는 단계 (데이터, 객체 등)

When
실제로 어떤 동작을 실행하는 단계

Then
결과를 검증하는 단계


// Given
"테스트 준비" 구간이라는 표시

TodoRequestDto requestDto = new TodoRequestDto();
TodoRequestDto 타입의 객체를 하나 새로 만들고, 변수 이름을 requestDto 라고 합니다

TodoRequestDto
할 일을 생성할 때 클라이언트가 보내는 요청 데이터를 담는 DTO(Data Transfer Object ) 클래스

new TodoRequestDto() : TodoRequestDto 객체를 새로 생성

requestDto : 생성된 객체를 담는 변수 이름.


TodoRequestDto requestDto = new TodoRequestDto();
TodoRequestDto 라는 클래스의 새로운 객체를 만들어서, 그걸 requestDto 라는 변수에 담는다


Todo savedTodo = new Todo("API 테스트");

Todo
Todo 라는 클래스 (할 일을 표현하는 엔티티, 즉 DB에 저장될 객체)

savedTodo
변수 이름
새로 만든 Todo 객체를 담아두는 역할

=
오른쪽에서 만든 객체를 왼쪽 변수에 대입합니다.

new Todo("API 테스트")
-> Todo 클래스의 생성자를 호출해서 새로운 객체를 생성하는 부분입니다.

"API 테스트" 라는 문자열을 생성자의 인자로 넘기고 있다.






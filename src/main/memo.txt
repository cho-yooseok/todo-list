todoText.textContent = todo.title;

앞에서 만든 <span> 요소(todoText) 안에, todo 객체의 title 속성 값을 텍스트로 넣는 코드입니다.

textContent -> HTML 요소 안에 표시될 텍스트를 의미.(innerText와 비슷하지만 HTML태그는 무시하고 텍스트 그대로 넣음)

todo.title -> todo 라는 객체 안에 있는 title 이라는 속성 값

예를 들어 todo 객체가 이렇게 생겼다면
const todo = { id: 1, title: "운동하기", completed: false};

실행결과는
<span class="todo-text"> 운동하기</span>

즉, 할 일 제목을 화면에 표시하는 역할




if(todo.completed) {
        todoText.classList.add('completed-text');
}

todo.completed -> todo 객체의 완료 여부 (Boolean 값)
true 라면 완료된 일
false 라면 아직 미완료

classList.add('completed-text')
-> todoText 요소에 "completed-text" 라는 css 클래스를 추가

즉
할일이 완료된 상태라면(span에 완료 스타일을 적용) 한다는 뜻입니다.


css

.completed-text {
    text-decoration: line-through;
    color: gray;
}

결과 : 완료된 todo는 화면에서 회색 취소선이 그어진 텍스트로 보이게 됩니다.





if(todo.completed) {
todoText.classList.add('completed-text');
}

위 코드는 자바스크립트에서 특정 조건이 만족 되었을 때
html 요소의 스타일을 변경하는 로직의 일부입니다.
할 일 목록(To-Do List) 애플리케이션에서 흔히 사용되는 패턴입니다.

if(todo.completed) {
    todoText.classList.add('completed-text');
}

if(todo.completed)
todo 라는 객체(Object)에 completed 라는 속성(Property)이 있는지 확인합니다.
만약 completed 속성의 값이 true 이면 {} 안의 코드를 실행합니다.
이는 '할 일이 완료되었는가?'를 묻는 조건문입니다.

todoText.classList.add('completed-text')
todoText는 HTML요소를 가리키는 변수입니다.(예 : 특정 할 일 항목의 텍스트 부분)
classList는 해당 HTML요소가 가지고 있는 모든 CSS클래스(class)의 목록입니다.
.add('completed-text')는 이 목록에 'completed-text' 라는 새로운 클래스를 추가하는 명령어입니다.

결론적으로, 이 코드는 "만약 todo 객체의 completed 상태가 true(완료됨)이면, todoText라는 HTML 요소에 completed-text 라는
CSS 클래스를 추가하라"는 의미입니다.
이렇게 클래스를 추가하면, 미리 정의된 CSS 스타일에 따라 해당 텍스트의 모양이 바뀌게 됩니다.
(예: 취소선이 그어지거나 글자색이 회색으로 변하는 등
)





/*
특정 투두 항목을 '수정 모드'로 변경하는 함수

동작 흐름
1. 기존의 텍스트(todoText)를 입력창(<input>)으로 교체
2. 액션 버튼 영역(actionButtons)에 "저장" & "취소" 버튼을 표시
3. 입력창에 포커스를 주어 바로 수정 가능하도록 함
4. 엔터(Enter)키 -> 저장 실행 / ESC 키 -> 수정 취소
*/


function editTodo(todo, li, todoText, actionButton) {
// editTodo 라는 이름의 함수를 정의한다

// todo
// 투두 항목 하나의 데이터 객체 (예:{id: 1, title: "공부하기", completed: false})
// 즉 수정하려는 할 일(Todo)의 정보를 담고 있음

// li
// HTML 문서에서 리스트 항목<li> 요소
// 즉, 화면에 표시되는 "할 일 하나"에 해당하는 DOM 요소

// todoText
// 해당 li 안에 표시되고 있던 텍스트 노드나 텍스트가 들어있는 요소(span 등)
// 이걸 나중에 입력창<input>으로 교체하기 위해 전달받음

// actionButton
// 해당 투두 항목에서 "버튼 영역"을 담당하는 DOM 요소
// (예: [수정] [삭제] 버튼이 들어가는 컨테이너)
// 수정 모드로 바뀔 때는 이 부분에 "저장"/"취소" 버튼이 다시 들어감

// editTodo 함수는 특정 투두(todo) 객체와, 그 객체를 표현하는 HTML 요소들(li, todoText, actionButton)을 받아서,
// 해당 투두 항목을 수정 모드로 바꿔주는 역할을 한다.


    //***** 1. 새로운 입력창 생성 (기존 todo.title 값을 기본값으로 채워 넣음) *****
    const editInput = document.createElement('input');
    // const
    // 상수(재할당 불가 변수)를 선언하는 키워드
    // (editInput) 변수는 다른 값으로 바꿀 수 없지만, 그 안에 담긴 객체의 속성은 변경 가능

    // editInput
    // 새로 만든 HTML 요소 <input> 를 담을 변수 이름

    // document.createElement('input')
    // 자바스크립트에서 DOM API 를 이용해 새로운 HTML 태그 요소를 만드는 메서드
    // 'input'이라는 문자열을 넣었으므로 <input> 태그가 생성됨.
    // 이 시점에는 화면에 보이지 않고, 메모리 안에서만 존재함
    // 나중에 append, replaceChild 같은 메서드로 DOM에 추가해야 브라우저 화면에 나타남

    // editInput 이라는 변수에 새로운 <input> 입력창 요소를 만들어 담는다
    // 브라우저 메모리 안에 <Input> 태그 하나를 만든다
    // 아직 화면에 붙이지 않았으니, 바로 눈에 보이진않는다.


    editInput.type = 'text';
    // 입력타입은 텍스트

    editInput.value = todo.title;
    // 현재 투두 항목의 제목을 기본값으로 설정

    editInput.className = 'edit-input';
    // 스타일을 위한 CSS 클래스명 지정




    // 2. "저장"버튼 생성
    const saveBtn = document.createElement('button');

    saveBtn.className = 'save-btn';
    // 저장 버튼 CSS 클래스

    saveBtn.textContent = '저장'
    // 버튼에 보이는 텍스트


    // 4. 기존의 텍스트(todoText)를 입력창으로 교체
    li.replaceChild(editInput, todoText);

    // 5. 액션 버튼 영역을 비우고 -> "저장" / "취소" 버튼 삽입
    actionButtons.innerHTML = '';
    // 기존 버튼 제거

    actionButtons.append(saveBtn, cancleBtn);
    // 새 버튼 2개 추가


    // 6. 입력창에 포커스를 줘서 사용자 입력 준비
    editInput.focus();

    // 7. 키보드 이벤트 처리
    const handleKeyDown = (event) => {
    // handleKeyDown 이라는 이름의 함수를 만든다. 이 함수는 키보드 이벤트 객체 event를 받아서 실행된다.

    // (event) => {...}
    // 화살표 함수(Arrow Function) 문법
    // event는 함수가 호출될 때 전달받는 이벤트 객체를 의미
    // 예 : 키보드 이벤트가 발생하면, event.key  같은 속성으로 어떤 키가 눌렸는지 알 수 있음

        if (event.key === 'Enter') {
            // Enter 입력 시 -> 저장 실행

           // 사용자가 누른 키가 Enter 키일 경우, 아래 코드를 실행한다.

            event.preventDefault();
            // 폼 제출 등 기본 동작 방지

            saveTodo(todo.id, editInput.value);
            // 수정된 값으로 저장 함수 호출

            // saveTodo 라는 함수를 호출하면서 두 개의 인자를 전달한다

            // todo.id
            // 현재 todo(할 일) 객체의 고유 ID 값

            // editInput.value
            // 입력창(editInput)에 사용자가 입력한 텍스트값

            // saveTodo(할일ID, 수정된 텍스트);
            // 형태로 특정 할 일을 수정된 내용으로 저장하라  는 동작을 실행하는 코드

        } else if (event.key === 'Escape') {
        // 만약 사용자가 Escape(키보드의 Esc) 키를 눌렀다면 이라는 뜻

        // event.key
        // 사용자가 누른 키보드 키 값을 의미함

        // 'Escape'
        // 키보드의 ESC 키


            // Escape 입력 시 -> 수정 취소하고 목록 다시 갱신
            updateListBasedOnFilter();
            // updateListBasedOnFilter(); 함수를 실행한다.
            // 말 그대로 현재 선택된 필터 조건에 따라 할 일 목록을 갱신(업데이트) 한다 는 의미

            // 즉, 현재 적용된 필터에 맞춰  화면에 보이는 리스트를 다시 그려라     라는 코드
        }
    };
}




editInput.addEventListener('keydown', handleKeyDown);

editInput
어떤 입력창 (예 : 할 일 수정입력 필드)

.addEventListener('keydown', handleKeyDown)
입력창에서 키보드가 눌렸을 때 (keydown 이벤트), handlekeyKown 함수를 실행하라는 의미

즉,
사용자가 입력창에 키를 누르면 handleKeyDown 함수가 호출된다.

보통 이 안에서는
Enter
수정 내용 저장
Escape
수정 취소



saveBtn.addEventListener('click', () => saveTodo(todo.id, editInput.value));

saveBtn
"저장" 버튼

.addEventListener('click', ...)
버튼을 클릭했을 때 실행할 동작을 등록

() => saveTodo(todo.id, editInput.value)
화살표 함수, 클릭되면 saveTodo 함수를 호출하면서
todo.id (할 일의 고유 ID)
editInput.value (입력창에 입력된 수정된 텍스트 값)
을 전달

즉,
저장버튼을 클릭하면, 해당 할 일의 ID와 입력된 수정 내용을 saveTodo함수로 보내 저장한다



cancelBtn.addEventListener('click', () => updateListBasedOnFilter());

cancelBtn
"취소" 버튼

.addEventListener('click', ...)
취소 버튼이 클릭되었을 때 실행할 동작을 등록

() => updateListBasedOnFilter()
화살표 함수, 클릭 시
updateListBasedOnFilter() 함수를 호출

즉,
취소 버튼을 클릭하면, 현재 적용된 필터 조건에 맞춰 다시 목록을 갱신한다.

주로 수정 중이던 입력창을 닫고 원래의 할 일 목록 화면으로 되돌아가는 용도로 쓰임


/*
현재 활성화된 필터를 기준으로 목록을 업데이트하는 함수
*/
function updateListBasedOnFilter() {

    const activeFilterBtn = document.querySelector(.'.filter-container button.active');
    // .filter-container 안에서 현재 'active' 클래스를 가진 버튼을 찾아옴

    const filter = activeFitlerBtn.id.replace('show-','');
    // 버튼의 id 값에서 'show-' 부분을 제거하고 필터 이름만 추출
    // 예 : id= "show-all" -> filter="all"

    fetchTodos(filter);
    // 추출한 필터 값을 사용하여 할 일 목록을 다시 불러옴

    /*
    필터 버튼의 활성 상태를 시각적으로 변경하는 함수
    */
    function setActiveFilter(activeButton) {

        document.querySelectorAll('.filter-container button'.).forEach(btn => btn.classList.remove());
        // 모든 필터 버튼에서 'active' 클래스를 제거(초기화)

        activeButton.classList.add('active');
        // 클릭된 버튼에만 'active' 클래스를 추가 (선택된 버튼 강조)
}




const activeFilterBtn = document.querySelector('.filter-container button.active');

const activeFilterBtn
activeFilterBtn 이라는 함수를 선언 (바뀌지 않는 변수)

document.querySelector(...)
HTML문서에서 조건에 맞는 첫 번째 요소를 찾아옴

'.filter-container button.active'
CSS 선택자

.filter-container
클래스가 filter-container 인 요소

button.active
그 안에서 클래스가 active인 button 요소

즉
filter-container 안에서 active 클래스를 가진 버튼 요소를 찾아서 activeFilterBtn 에 저장한다


.querySelector(...)
.querySelector(...) 는 DOM API 메서드로, HTML 문서 안에서 특정 CSS 선택자와 일치하는 첫 번째 요소를 찾아 반환하는 기능입니다.

document
HTML 전체 문서를 가리킴

.querySelector('선택자')
지정한 CSS 선택자에 맞는 첫 번째 요소를 가져옴


('.filter-container button.active')
이 부분은 CSS 선택자입니다.

선택자 해석
.filter-container
클래스 이름이 fitler-container 인 요소

button.active
button 태그이면서 동시에 active 클래스를 가진 요소

띄어쓰기 (.filter-container  button.active)

자식/후손 관계를 의미
즉, filter-container 안에 있는 button.active

('.filter-container button.active')
filter-container 안에 있는 버튼 중, active 클래스를 가진 버튼



206

    /**
     * 현재 활성화된 필터를 기준으로 목록을 업데이트하는 함수
     */
    function updateListBasedOnFilter() {
        const activeFilterBtn = document.querySelector('.filter-container button.active');
        const filter = activeFilterBtn.id.replace('show-', '');
        fetchTodos(filter);
    }

    /**
     * 필터 버튼의 활성 상태를 시각적으로 변경하는 함수
     */
    function setActiveFilter(activeButton) {
        document.querySelectorAll('.filter-container button').forEach(btn => btn.classList.remove('active'));
        activeButton.classList.add('active');
    }



const filter = activeFilterBtn.id.replace('show-','');
버튼의 id에서 "show-" 접두어를 제거한 문자열을 filter 변수에 담는 코드
즉, 현재 어떤 필터 버튼이 눌렸는지를 문자열("all", "completed", "incompleted")로 저장하는 역할을 합니다.



activeFilterBtn.id
activeFilterBtn 이라는 버튼 요소의 id 속성을 가져옵니다.

.replace('show','')
문자열에서 show-  라는 부분을 빈 문자열 ''  로 바꿉니다.
즉, "show-" 접두어를 제거하는 동작입니다.

예시
"show-all".replace('show-','') -> "all"
"show-completed".replace('show-', '')

const filter = ...
이렇게 처리된 결과 문자열을 filter 변수에 저장합니다.



fetchTodos(filter);
현재 선택된 필터 기준   으로 할 일 목록을 가져오는 함수를 실행하는 코드
filter 가 "all" -> 모든 할 일 불러오기



fetchTodos
정의해둔 함수 이름
할 일 목록(Todos)을 가져오는 역할을 합니다.


(filter)
앞서 만든 filter 변수를 함수의 인자로 전달합니다.
filter 값은 "all", "completed", "incompleted" 중 하나
이 값에 따라 어떤 Todo 목록을 불러올지 결정



function setActiveFilter(activeButton) {
}
setActiveFilter 라는 이름의 함수를 정의하는데,
이 함수는 클릭된 버튼(activeButton)을 기준으로 현재 활성화된 필터를 설정하는 역할을 합니다.




function
새로운 함수를 정의할 때 사용하는 키워드

setActiveFilter
함수 이름
직역하면  활성화된 필터를 설정한다  라는 의미
보통UI 에서 어떤 필터 버튼이 선택되었는지 표시하거나,
선택된 버튼에 맞게 동작을 바꾸는 역할을 합니다.

(activeButton)
-> 이 함수가 받을 매개변수(parameter)
activeButton 은 사용자가 클릭한 필터 버튼 요소 (예 : show-all, show-completed, show-incomplete 버튼 중 하나)를
의미합니다.





document.querySelectorAll('.filter-container button')
    .forEach(btn => btn.classList.remove('active'));


1. document.querySelectorAll('.filter-container button')

document.querySelectotAll(...)
html문서에서 특정 선택자(selector) 에 해당하는 모든 요소를 선택합니다.

.filter-container button
.filter-container 라는 클래스 안에 있는 모든 버튼(button)요소를 선택한다는 뜻

즉,
필터 버튼 전체를 가져오는 코드입니다.



function setActiveFilter(activeButton) {
}
setActiveFilter 라는 이름의 함수를 정의하는 구문
setActiveFilter 함수이름(필터 버튼을 활성화시키는 역할을 의미)
activeButton
함수에 전달되는 매개변수(parameter), 즉 "현재 활성화시킬 버튼 요소"를 의미
-> 즉, 전달받은 버튼을 활성화 상태로 설정하는 함수의 시작 부분 이라는 뜻


document.querySelectorAll('.filter-container button').forEach(btn => btn.classList.remove('active'));

의미는
".filter-container 안에 있는 모든 버튼 요소를 찾아서, 각각의 버튼에서 'active'라는 클래스를 제거한다"  입니다.


document.querySelectorAll('.filter-container button')
-> HTML 문서에서 .filter-container 라는 클래스를 가진 요소 안의 모든 <button> 태그를 선택

.forEach(...)
선택된 버튼들을 하나씩 순회

btn.classList.remove('active')
각 버튼의 class 목록에서 'active' 클래스를 제거

btn.classList.remove('active')
버튼(btn) 요소의 클래스 목록에서 'active' 라는 클래스를 제거한다.
btn
-> 반복문(forEach)에서 순회 중인 버튼 요소
.classList
해당 요소의 class 속성을 제어할 수 있는 객체
.remove('active')
클래스 목록에서 'active'를 삭제
버튼이 활성화 표시(선택 상태) 되어 있었다면 그 표시를 없애는 것입니다.
모든 버튼의 활성화 상태를 초기화한 뒤 -> 선택된 버튼만 다시 add('active')로 활성화하기 위해서입니다.

즉, 기존에 활성화돼 있던 버튼의 'active'상태를 모두 초기화하는 과정입니다.


activeButton.classList.add('active');
activeButton으로 전달된 버튼에 'active' 클래스를 추가한다 입니다

activeButton
함수 매개변수로 받은 "클릭된(또는 활성화하려는) 버튼" 요소

.classList.add('active')
해당 버튼의 class 속성에 'active'라는 이름의 CSS 클래스를 추가

즉,
방금 전의 모든 버튼에서 'active' 클래스를 제거했다가,
선택된 버튼에만 'active'클래스를 붙여서 활성화 표시를 해주는 것



addButton.addEventListener('click',handleAddTodo);
addButton(추가 버튼) 을 클릭했을 때 handleAddTodo 함수를 실행하도록 이벤트를 등록한다.

addButton
HTML에서 id="add-button" 같은 식으로 선택된  추가 버튼 요소

.addEventListener('click', ...)
이 버튼에 클릭 이벤트 리스너를 붙임

handleAddTodo
클릭 시 실행할 함수(할 일을 추가하는 기능 담당)

즉, 버튼을 누르면 할 일이 리스트에 추가되는 로직(handleAddTodo 함수)이 실행됨


todoInput.addEventListener('keypress', (event) => {     )
todoInput(할 일 입력창)에서 키보드가 눌릴 때마다 event 를 전달받아 실행되는 함수를 등록한다

todoInput -> <input> 입력창 요소 ( 예: id="todo-input" )
.addEventListener('keypress', )
입력창에서 키가 눌렸을 때 발생하는 이벤트(keypress)를 감지

(event) => {...}
화살표 함수, 눌린 키에 대한 정보를 event 객체로 받아옴

즉, 사용자가 입력창에서 키보드를 누를 때 실행되는 동작을 정의하는 부분

보통 이 안에서 Enter 키를 눌렀는지 확인하고, Enter 라면 새로운 할 일을 추가하는 코드가 들어간다


if(event.key === 'Enter') handleAddTodo();

사용자가 누른 키 (event.key) 가 "Enter"라면 handleAddTodo() 함수를 실행한다

event.key
지금 눌린 키의 이름 (예 : "a","1","Enter")

=== 'Enter'
눌린 키가 Enter 인지 확인하는 조건문

handleAddTodo();
조건이 참일 때 실행, 즉 할 일을 추가하는 함수 실행

->
즉, 입력창에서 Enter를 누르면 버튼 클릭 없이도 새 할 일이 추가되도록 동작하는 것입니디ㅏ.

요약:
버튼을 누르거나 Enter를 치면 같은 기능 (handleAddTodo)이 실행되도록 만든 것입니다.



btn.classList.remove('active')
버튼(btn) 요소의 클래스 목록에서 'active'라는 클래스를 제거한다
btn
반복문(forEach)에서 순회 중인 버튼 요소
.classList
해당 요소의 class 속성을 제어할 수 있는 객체
.remove('active')
클래스 목록에서 'active'를 삭제

즉
버튼이 활성화 표시(선택 상태) 되어 있었다면 그 표시를 없애는 것

이게 실행되는 이유는,
모든 버튼의 활성화 상태를 초기화한 뒤
선택된 버튼만 다시
add('active')로 활성화하기 위해서





filterContainer.addEventListener('click',(event) => {
)

filterContainer 요소에 클릭 이벤트 리스너를 등록한다는 뜻
즉, 사용자가 filterContainer (예 : 버튼들이 들어있는 컨테이너 같은 DOM 요소)를 클릭했을 때,
뒤에 오는 함수 ( (event) => {...} ) 가 실행하도록 설정한 것

(event) 는 클릭 이벤트가 발생했을 때의 이벤트 객체를 의미

{...} 안에는 클릭시 실행할 코드들이 들어감

쉽게 말하면
filterContainer 를 클릭하면 이 안의 코드를 실행하라


const clickedButoon = event.target.closest('button');

event.target
사용자가 실제로 클릭한 DOM 요소를 뜻합니다.

.closest('butoon')
클릭된 요소에서 가장 가까운 button 태그를 찾아 반환합니다.
만약 클릭한 곳이 버튼 안의 <span> 같은 자식 요소라면, 그 부모인 <button>을 찾아줍니다.
버튼이 아니면 null을 반환합니다.
즉,
사용자가 클릭한 위치에서 가장 가까운 <button> 요소를 찾아 clickedButton 변수에 저장한다.



if(!clickedButton) return;
클릭한 요소가 버튼이 아니면 함수를 실행하지 말고 바로 종료해라

!clickedButton
clickedButton 이 없다 (null 또는 undefined다) 는 뜻

즉, 사용자가 클릭한 곳이 버튼이 아니라면 true가 됩니다.

return;
그냥 함수 실행을 멈추고 빠져나간다는 의미

클릭한 요소가 버튼이 아니면 함수를 실행하지 말고 바로 종료해라

즉, 버튼 외의 영역(예: 빈 공간, 텍스트 등)을 클릭했을 때는 이벤트가 무시되도록 하는 안전 장치



const filter = clickedButton.id.replace('show','');

clickedButton.id
사용자가 클릭한 버튼의 id 값을 가져옵니다.

.replace('show','')
id값에서 show- 라는 글자를 찾아서 빈 문자열 ""  로 바꿔 제거합니다.
결과를 filter 변수에 저장합니다.

예시
버튼의 id가 "show-completed" 라면 -> completed
버튼의 id가 "show-active"라면 -> "active"
버튼의 id가 "show-all"라면 -> "all"

즉,
클릭한 버튼의 id에서 show- 라는 접두사를 빼고, 나머지 부분만 filter 변수에 저장한다


filter는 어떤 할 일 목록을 보여줄지 (예: 전체, 완료됨, 진행중)를 구분하는 역할을 하게 됩니다.


setActiveFilter(clickedButton);
setActiveFilter 라는 함수를 호출하면서 사용자가 클릭한 버튼 clickedButton 을 인자로 전달합니다.




총 해석
->
1. filterContainer 클릭 감지
2. 클릭된 요소에서 가장 가까운 <button> 찾기
3. 버튼이 아니면 종료
4. 버튼의 id에서 show- 제거       ->    filter 값 추출
5. 그 버튼을 활성 버튼으로 표시



fetchTodos(filter);
fetchTodos라는 함수를 호출하면서, 앞에서 구한 filter 값을 인자로 넘깁니다.
이 함수는 보통 서버나 로컬데이터에서 할 일 목록(Todos)을 불러오되, 필터 조건에 맞게 가져오는 역할을 합니다.

filter가 "all" -> 전체 할 일 불러오기
filter가 "completed" -> 완료된 할 일만 불러오기
filter가 "active" -> 진행 중인 할 일만 불러오기

"선택된 필터 조건에 맞는 할 일 목록을 불러와서 화면에 표시해라"

정리
1.filterContainer 클릭 감지
2.클릭된 버튼 찾기 (clickedButton)
3.버튼 아니면 종료
4. 버튼id에서 "show-" 제거 -> filter 값 추출
5. 클릭된 버튼을 활성화 표시
6. filter 조건으로 할 일 목록 다시 불러오기



주석
// 필터 버튼 클릭 이벤트 등록 (이벤트 위임 방식 사용)
// filterContainer 안에서 발생하는 클릭 이벤트를 한 번만 감지하고,
// 실제 클릭된 버튼에 따라 동작을 다르게 처리합니다.
filterContainer.addEventListener('click', (event) => {

    // 사용자가 클릭한 요소에서 가장 가까운 <button> 요소를 찾음
    // (버튼 안의 <span> 같은 요소를 눌러도 해당 버튼이 인식되도록 함)
    const clickedButton = event.target.closest('button');

    // 클릭된 요소가 버튼이 아니면 함수 실행 중단
    // (즉, 버튼 영역 외 클릭은 무시)
    if(!clickedButton) return;

    // 버튼의 id 에서 "show-" 라는 접두사를 제거해 필터 이름만 추출
    // 예 : "show-completed" -> "completed"
    const filter = clickedButton.id.replace('show-', '');

    // 클릭된 버튼을 활성화 상태로 표시 (예 : CSS class "active" 추가)
    // 동시에 다른 버튼들에서는 활성화 표시 제거
    setActiveFilter(clickedButton);

    // 선택된 필터 조건에 맞는 할 일 목록 불러오기
    // 예 : "all" -> 전체, "completed" -> 완료된 항목
    fetchTodos(fitler);
});

해설(흐름 요약)
1. filterContainer(버튼들을 감싼 부모 요소)에 클릭 이벤트를 걸어둔다 (이벤트 위임 -> 버튼 개수만큼 리스너를 안 달아도 됨)
2. 실제 클릭된 요소가 버튼인지 확인한다 (버튼이 아니라면 무시)
3. 버튼id에서 "show-" 를 제거해 어떤 필터인지 (all, completed) 알아낸다
4. 클릭된 버튼을 시각적으로 활성화 표시한다
5. 해당 필터 조건에 맞춰 할 일 목록을 다시 가져온다.




const clickedButton = event.target.closest('button');

event
누가 어디를 클릭했는지 정보가 들어있는 상자

event.target
사용자가 정확히 클릭한 그 요소. (버튼 안의 글자 <span>이나 아이콘 <i> 일 수도 있다.)

.closest('button')
지금 요소에서 위로 위로(부모 방향)올라가며 가장 가까운 <button>을 찾아 준다.
자기 자신이 이미 <button> 이면 그걸 바로 돌려줍니다.
끝까지 올라가도 버튼이 없으면 null

사용자가 클릭한 곳에서 시작해, 위쪽으로 올라가며 제일 가까운 버튼 요소를 찾아 clickedButton 에 담는다


과정
1. 사용자가 클릭함 -> 브라우저가 event를 만든다
2. event.targe은 실제로 맞은 요소
예 : <span> 아이콘 </span>  같은 버튼의 자식
3. closest('button') 가 다음과 같이 움직인다
 지금 요소가 <button> 인가? -> 맞으면 그 버튼 반환
 아니면 부모로 한 칸 올라감 -> 또 <button> 인가? -> 맞으면 반환
 최상단까지 가도 못 찾으면 null 반환

 왜 이렇게 쓰나? (이벤트 위임에 딱!)
 버튼 안에는 보통 글자, 아이콘, <span>, <svg> 같은 자식 요소들이 있다.
 사람은 버튼을 눌렀지만, 실제로는 그 자식 요소를 클릭한 것으로 잡히는 경우가 많다
 closest('button')을 쓰면 무조건 버튼 본체를 안전하게 찾아낼 수 있습니다.


작은 예시
<div class = "filter-container">
    <button id ="show-all"><span>전체</span></button>
    <button id ="show-active"><i>진행중</i></button>
    <button id ="show-completed">완료</button>
</div>

전체 글자 <span>를 클릭 -> event.target 은 <span>
-> .closest('button')는 그 부모 버튼 (#show-all)을 찾아서 반환

진행중 아이콘 <i> 클릭 -> 부모 버튼 #show-active반환
버튼이 아닌 빈 공간 클릭 -> 위로 올라가도 <button>없음 -> null
-> 그래서 보통 바로 다음 줄에 if(!clickedButton) return; 같은 안전 체크를 합니다.



.target
누구를 정확히 클릭했는지 알려주는 속성
event.target = 사용자가 클릭한 진짜 요소

버튼 안에 글자 <span> 나 아이콘 <i>이 있으면, 그걸 클릭한 걸로 잡음

html
<button>
    <span>클릭</span>
</button>

<span> 글자를 클릭하면 -> event.target 은 <span>
버튼 테두리 직접 클릭하면 -> event.target 은 <button>

즉,
target은 "마우스가 실제로 맞은 그 지점 요소"


.closest('선택자')
가까운 부모 중에 이 조건(선택자)에 맞는 걸 찾아줘
지금 요소 자신부터 검사 -> 없으면 위로 올라가며(부모 방향) 검사
제일 가까운 조건 맞는 요소 반환
끝까지 없으면 null


html
<div class="box">
    <button id ="btn">
        <span>글자</span>
    </button>
</div>

js
const span = document.querySelector('span');
span.closest('button'); // <button id ="btn">...</button>
span.closest('.box');   // <div class="box">...</div>
span.closest('div');    // <div class="box">...</div>
span.closest('ul');     // null (못 찾음)

즉,
.closest() 는  "나부터 시작해 위쪽으로 올라가면서 제일 가까운 특정 태그/클래스를 찾아라"

두 개를 합치면

event.target
실제 클릭된 요소

event.target.closest('button')
클릭된 요소에서 시작해 버튼 본체를 찾는 것




todoList.addEventListener('click',(event) => {
)

todoList 라는 DOM 요소 (예 : <ul> 같은 리스트)에 클릭 이벤트 리스너를 등록하는 코드입니다.

사용자가 todoList 영역안의 어떤 부분을 클릭하면, 뒤에 정의된 화살표 함수 (event) => {...} 가 실행됩니다.

(event) 는 이벤트 객체를 받아와서, 클릭된 대상(event.target) 등과 같은 정보를 사용할 수 있게 해줍니다.

즉, todoList 영역을 클릭했을 때 실행할 동작을 지정하는 코드입니다.



js
const li = event.target.closest('li');

event.target
사용자가 실제로 클릭한 HTML 요소 (예: <span>, <button> 같은 것)

.closest('li')
클릭된 요소에서 가장 가까운 조상요소(ancestor) 중에서 <li>태그를 찾아 반환.

만약 클릭한 게 <span> 이라도, 그 <span>이 <li> 안에 있으면 해당<li>요소를 찾아줌
<li>를 찾을 수 없으면 null 반환

즉,
클릭한 요소가 속한 가장 가까운 <li>요소를 찾아서 li변수에 담는다

보통 투두리스트에서 어떤항목(li)이 클릭되었는지 찾기 위해 쓰입니다.


js
if (!li) return;

!li -> li 가 null 또는 undefined인 경우 (즉, <li> 요소를 못 찾았을 경우)

return
그 즉시 함수를 종료시켜 더 이상 실행하지 않음

즉,
"만약 클릭된 요소가 <li> 안에 속해 있지 않다면, 함수 실행을 멈추고 아무 것도 하지 않는다"

이렇게 해주면 todoList 안의 빈 영역이나 <li> 밖을 클릭했을 때 불필요한 오류나 동작이 실행되지 않게 막는 역할을 합니다.




const id = Number(li.dataset.id);
li.dataset.id   ->  <li> 요소에 있는 data-id 속성 값을 가져옴
예 : <li data-id="3"> 라면 li.dataset.id 는 "3" 문자열

Number(...)
문자열 "3" 을 숫자 3으로 변환

즉,
클릭된 <li> 요소의 data-id 값을 숫자로 변환해 id 변수에 저장한다.

보통 투두 리스트 같은 곳에서 각 항목에 고유한 id를 붙여두고,
그걸 이용해 어떤 항목을 수정하거나 삭제할지 식별할 때 사용합니다.


const id = Number(li.dataset.id);

li.dataset.id
<li> 요소에 있는 data-id 속성 값을 가져옴

예 : <li data-id="3"> 라면 li.dataset.id 는 "3" (문자열)

Number(...)
문자열 "3"을 숫자 3으로 변환

즉,
클릭된 <li> 요소의 data-id 값을 숫자로 변환해 id 변수에 저장한다

보통 투두 리스트 같은 곳에서 각 항목에 고유한 id를 붙여두고, 그걸 이용해 어떤 항목을 수정하거나 삭제할지 식별할 때 사용합니다.

const targetClass = event.target.class.Name;

event.target
사용자가 실제 클릭한 요소 (예: 버튼, 텍스트, 체크박스)

.className
그 요소에 지정된 CSS클래스 이름 전체 문자열을 가져옴

예를 들어
<button class="delete-btn">삭제</button>

이 버튼을 클릭했다면
event.target.className 의 값은 "delete-btn"이 됩니다.

즉,
"클릭된 요소의 클래스 이름을 문자열로 가져와 targetClass 변수에 저장한다

이 값은 보통
if(targetClass === 'delete=btn') {...} 처럼 조건문에서 삭제 버튼인지, 수정버튼인지 등을 구분할 때 쓰입니다.



if(targetClass === 'toggel-btn') {
}

targetClass
방금 가져온 클릭된 요소의 클래스 이름

=== 'toggle-btn'
그 클래스 이름이 "toggle-btn" 과 정확히 일치하는지 비교

즉
클릭된 요소가 toggle-btn 클래스라면, 아래에 정의된 동작을 실행한다.

보통 이 부분은 할 일 완료/미완료 상태를 전환하는 버튼을 눌렀을 때 실행되는 조건문


toggleTodo
미리 정의된 함수 이름 (할 일을 토글 (완료 <-> 미완료 전환)하는 기능 담당
(id) -> 클릭된 <li> 요소의 고유한 id 값을 인자로 전달
즉,
"해당 id를 가진 투두 항목의 상태(완료/미완료)를 바꾸는 함수를 실행한다"

예를 들어,
id = 3 이라면
toggleTodo(3) 호출
-> id가 3인 할 일의 상태를 반대로 변경



} else if (targetClass === 'delete-btn') {

해석
else of ->
앞의 조건 (toggle-btn) 이 거짓일 때, 새로운 조건을 검사

targetClass === 'delete-btn'
-> 클릭된 요소의 클래스 이름이
"delete-btn"인지 확인

즉,
클릭된 요소가 delete-btn 클래스라면, 아래에 정의된 동작을 실행한다

보통 이 구문은
toggle-btn
완료 상태 토글

delete-btn
할 일 삭제

처럼 버튼의 용도에 따라 다른 기능을 실행하도록 구분하는 역할을 합니다.



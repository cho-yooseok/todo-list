/**
 * 서버 API 호출을 위한 헬퍼(도우미) 함수
 * @param {string} url - 요청을 보낼 서버의 URL 주소
 * @param {object} [options] - fetch 함수에 전달할 추가 옵션 객체 (예: method, headers, body 등)
 * @returns {Promise<any>} 성공 시에는 JSON으로 변환된 응답 객체를, 실패 시에는 에러를 발생시키는 프로미스(Promise)를 반환
 */
async function fetchHelper(url, options) {
    // 1. fetch API를 사용해 실제 네트워크 요청을 보내고, 서버의 응답이 올 때까지 기다립니다.
    const response = await fetch(url, options);

    // 2. 서버 응답의 성공 여부를 확인합니다. (HTTP 상태 코드가 200-299 범위가 아니면 'ok'는 false가 됩니다.)
    if (!response.ok) {
        // 3. 응답이 실패한 경우, 서버가 보낸 에러 메시지(JSON 형태)를 파싱하려고 시도합니다.
        const errorData = await response.json()
            // 만약 서버 에러 메시지가 JSON 형태가 아니라서 파싱에 실패하면, 일반적인 에러 메시지를 대신 사용합니다.
            .catch(() => ({ message: '서버와 통신에 실패했습니다.' }));

        // 4. 파싱한 에러 메시지나 기본 HTTP 에러 메시지를 담은 새로운 에러 객체를 생성하여 던집니다(throw).
        // 이 에러는 이 함수를 호출한 쪽의 .catch() 블록에서 잡을 수 있습니다.
        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
    }

    // 5. 성공 응답 중에서도 내용(body)이 없는 경우를 특별히 처리합니다. (예: 삭제 요청 후 '204 No Content' 응답)
    if (response.status === 204 || response.headers.get("content-length") === "0") {
        // 내용이 없으므로 null을 반환하여, 호출한 쪽에서 불필요한 JSON 파싱을 시도하지 않도록 합니다.
        return null;
    }

    // 6. 성공 응답에 내용(body)이 있는 경우, 응답을 JSON 형태로 변환하여 반환합니다.
    return response.json();
}


1. async (Asynchronous의 약자)
async 를 함수 앞에 붙이면, 이 함수는 비동기 함수가 도비니다.

비동기 함수란?
함수 내부에 시간이 걸리는 작업(서버에 데이터 요청하고 기다리기)이 있더라도, 그 작업이 끝날 때까지 프로그램 전체를
멈추지 않고 다른 코드를 계속 실행할 수 있게 해주는 특별한 함수입니다.
사용자가 웹 페이지에서 다른 버튼을 누르는 등의 동작을 멈춤 없이 할 수 있게 해줍니다.

async 함수의 두 가지 주요 특징은 다음과 같습니다.
1. 함수 내에서 await 키워드를 사용할 수 있게 됩니다.
2. 함수는 항상 프로미스(Promise) 객체를 반환합니다. (작업이 성공하면 결과를, 실패하면 에러를 담고 있는 약속증서와
같은 객체)


function
지금부터 함수를 정의하겠다  라고 선언하는 자바스크립트의 기본 키워드입니다.


fetchHelper
개발자가 직접 지은 함수의 이름입니다.
이름에서 함수의 역할을 유추할 수 있습니다.
fetch : (서버 등에서 데이터를) 가져오다
Helper : 도우미
즉, "서버에서 데이터를 가져오는 (fetch) 작업을 도와주는 함수" 라는 의미를 가집니다.

(url, options)
이 함수를 호출할 때 전달해야 하는 매개변수(parameter) 또는 인자(argument) 목록입니다.
함수가 일을 하기 위해 필요한 재료들이라고 생각할 수 있습니다.

url : 통신을 요청할 서버의 주소(문자열)를 전달받을 변수입니다.
options : 요청에 대한 추가 설정값들 (예 : GET/POST 방식, 요청 헤더, 전송할 데이터 등)을 객체 형태로 전달받을 변수

결론적으로 async function fetchHelper(url, options) { 이 한줄은,
"서버와 비동기적으로 통신하는 것을 도와주는 fetchHelper 라는 이름의 함수를 지금 부터 정의하겠다.
이 함수는 호출될 때 url 주소와 options 설정값을 입력받는다"

라는 선언문입니다. 이 선언 덕분에 함수 내부에서는 await 을 사용하여 서버의 응답을 깔끔하게 기다릴 수 있게 됩니다.


const response = await fetch(url, options);

이 코드는 fetch 함수를 사용해 url 주소로 네트워크 요청을 보내고, 서버로부터 응답이 올때가지 기다린 후 , 그 응답 결과를
response라는 상수에 저장하라 는 의미입니다.

이 한 줄은 비동기(async/await) 프로그래밍의 핵심을 잘 보여줍니다.

1. await
'기다려'라는 의미의 키워드입니다.
async 함수 안에서만 사용할 수 있습니다.
await는 바로 뒤에 오는 코드(여기서는 fetch) 가 완료될 때까지 현재 함수의 실행을 일시 중지시킵니다.
가장  중요한 점은, 프로그램 전체를 멈추는 것이 아니라 오직 fetchHelper 함수의 실행 흐름만 잠시 멈춘다는 것입니다.
그동안 브라우저는 다른 작업(예 : 사용자 입력 처리, 애니메이션 등)을 할 수 있습니다.

fetch(...) 작업이 끝나고 프로미스(Promise)가 결과값(성공 또는 실패)을 가져오면, await은 그 결과값을 반환하고 멈췄던 함수의 실행을 재개합니다.
여기서는 서버의 응답 객첼르 반환합니다.



const errorData = await response.json().catch(() => ({message: '서버와 통신에 실패했습니다.'}));

이 코드는 "실패한 서버응답(response)의 본문을 JSON 형태로 변환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고,
그 최종 결과를 errorData 상수에 저장하라" 는 의미입니다.

const errorData = await response.json().catch(() =>({message: ' 서버와 통신에 실패했습니다.'}));

이 코드는 "실패한 서버응답(response)의 본문을 JSON 형태로 반환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고,
그 최종 결과를 errorData 상수에 저장하라" 는 의미입니다.

const errorData = await response.json().catch( () => ({message: '서버와 통신에 실패했습니다.'}));

이 코드는 "실패한 서버응답(response)의 본문을 JSON 형태로 반환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고,
그 최종 결과를 errorData 상수에 저장하라"는 의미입니다.

const errorData = await response.json().catch( () => ({message: '서버와 통신에 실패했습니다.'}));

이 코드는 "실패한 서버응답(response)의 본문을 JSON 형태로 반환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고,
그 최종 결과를 errorData 상수에 저장하라"는 의미입니다.

const errorData = await response.json().catch( () => ({message : ' 서버와 통신에 실패했습니다.'}));

이 코드는 "실패한 서버응답(response)의 본문을 JSON형태로 변환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고, 그 최종결과를 errorData 상수에 저장하라"
는 의미입니다.

이 코드는 결고한 에러 처리를 위한 두 가지 시나리오를 모두 대비하고 있습니다.

구성 요소별 상세 분석
response.json()
if(!response.ok) 블록 안에 있으므로, 이 코드가 실행될 때 response는 이미 서버로부터 받은 '실패' 응답객체입니다.
(예 : 404 Not Found, 500 Server Error 등)
많은 최신 API들은 실패 햇을 때 조차 에러의 원인을 설명하는 정보를 JSON 형식으로 본문(body)에 담아 보냅니다.
(예 : {"message" : "ID가 존재하지 않습니다"})

response.json()은 바로 이 본문을 읽어서 자바스크립트 객체로 변환(파싱)하려는 시도입니다.

이 변환 과정 자체도 비동기 작업이라 완료될 때까지 시간이 걸리므로, 결과를 얻으려면 await이 필요합니다.

await
response.json() 작업이 완료될 떄까지 기다리는 역할을 합니다.
성공할 경우 : 파싱된 자바 스크립트 객체(예: {message: "..."})를 반홥합니다.
실패할 경우 : 에러를 발생시킵니다.
respon.json()이 실패하는 대표적인 경우는
서버가 보낸 에러 응답 본문이 유효한 JSON 형태가 아닐 때 입니다.
(예 : 단순 텍스트 Internal Server Error 이거나, HTML 에러 페이지일 경우)

.catch(() => ({ message: '서버와 통신에 실패했습니다.'}))
이 부분이 바로  안전장치(Fullback) 입니다.
이 코드는 response.json()이 실패했을 때만 실행됩니다.

catch() 는 response.json()이 던진 에러를 가로챕니다
() => ({message: '...'})
에러를 가로챈 후, 미리 정의된 새로운 객체{message: '서버와 통신에 실패했습니다.'} 를 반환합니다.
이렇게 하면, 서버가 어떤 형태로 에러를 반환하든 우리 프로그램은 항상 {message: "..."} 라는 일관된 형태의
에러 객체를 갖게 되어 후속처리가 매우 쉬워집니다.

const errorData = ...
위 과정의 최종결과가 errorData라는 상수에 저장됩니다.


시나리오별 흐름 요약
이 코드가 어떻게 동작하는지 두 가지 시나리오로 나누어 볼 수 있습니다.

시나리오1: 서버가 친절하게 JSON형식으로 에러 정보를 보내준 경우
1. response.json()이 호출되고, 본문(예: {"message": "권한이 없습니다"})을 성공적으로 파싱합니다.
파싱(parsing)은 컴퓨터가 이해하기 어려운 특정 데이터 형식(주로 문자열 형태)을 컴퓨터가 쉽게 다룰 수 있는
구조화된 형식으로 변환하는 과정입니다.
컴퓨터가 이해할 수 있는 객체 형식으로 변환하여 줍니다.
여기서는
서버에서 보낸 데이터(예 : {"message":"권한이없습니다}") 를 JavaScript가 이해할 수 있는 객체 형식으로
변환하는 과정이 성공했다는 뜻입니다.

2. await
response.json() 작업이 완료될 때까지 기다리는 역할을 합니다.
성공할 경우 : 파싱된 자바스크립트 객체(예 : {message : "..."})을 반환합니다.
실패할 경우 : 에러를 발생시킵니다. response.json()이 실패하는 대표적인 경우는
서버가 보낸 응답 본문이 유효한 JSON 형식이 아닐 때 입니다.
(예 : 단순 텍스트 internal Server Error 이거나, HTML 에러 페이지일 경우)

3.    .catch(() => ({ message : '서버와 통신에 실패했습니다.'}))
이 부분이 바로 안전장치 Fullback 입니다. 이 코드는 response.json() 이
실패했을 때만 실행됩니다.
catch() 는 response.json() 이 던진 에러를 가로챕니다
() => ({message: '...'})
에러를 가로챈 후, 미리 정의된 새로운 객체 { message: '서버와 통신에 실패했습니다.'} 를 반환합니다
이렇게 하면, 서버가 어떤 형태로 에러를 반환하든 우리 프로그램은 항상
{message : ',,,'} 라는 일관된 형태의 에러 객체를 갖게 되어 후속 처리가 매우 쉬워집니다.

4. const errorData = ...
위 과정의 최종 결과과 errorData 라는 상수에 저장됩니다.

시나리오 별 흐름 요약
시나리오1. 서버가 친절하게 JSON형식으로 에러를 보내준 경우
1. response.json() 이 호출되고, 본문(예 : {"message" : "권한이 없습니다."}) 을 성공적으로 파싱합니다
2. await가 파싱한 객체 {message: "권한이 없습니다."} 를 반환합니다.
3. 파싱이 성공했으므로 .catch() 부분은 실행되지 않고 건너뜁니다
4. errorData 상수에는 {message: "권한이 없습니다."}  가 저장됩니다.

시나리오2. 서버가 JSON 이 아닌 다른 형식(예 : 일반 텍스트)으로 에러를 보낸 경우
1. response.json() 이 호출되지만, 본문(예 : "500 - Server Error")이 JSON이 아니라서
파싱에 실패하고 에러를 던집니다.
2. response.json() 의 프로미스가 거부(reject) 되면서  .catch() 블록이 실행됩니다.
3. .catch() 는 미리 준비된 객체 { message: '서버와 통신에 실패했습니다.'} 를 반환합니다.
4. errorData 상수에는  { message: '서버와 통신에 실패했습니다.'} 가 저장됩니다.

결론적으로, 이 한줄의 코드는 어떤 종류의 서버 에러가 발생하더라도 프로그램이 중단되지 않고,
항상 예측 가능한 형태의 에러 정보를 확보하도록 보장하는 매우 안정적인 프로그래밍 패턴입니다.


const errorData = await response.json().catch(() => ({message : '서버와 통신에 실패했습니다'})

이 코드는 "실패한 서버 응답(response)의 본문을 JSON 형태로 변환하려고 시도하되,
만약 그 변환 과정에서 오류가 발생하면 미리 준비된 기본 에러 메시지를 대신 사용하고,
그 최종 결과를 errorData 상수에 저장하라"는 의미입니다.

이 코드는 견고한 에러 처리를 위한 두 가지 시나리오를 모두 대비하고 있습니다.

1. response.json()
if(!response.ok) 블록 안에 있으므로 이 코드가 실행될 때
response는 이미 서버로부터 받은 '실패' 응답 객체입니다. (예 : 404 Not Found, 500 Server Error 등)
많은 최신 API들은 실패했을 때조차 에러의 원인을 설명하는 정보를 JSON 형식으로 본문(body)에 담아 보냅니다.
(예 : {"message" : "ID가 존재하지 않습니다." })
response.json() 은 바로 이 본문을 읽어서 자바스크립트 객체로 변환(파싱)하려는 시도입니다.
이 변환 과정 자체도 비동기 작업이라 완료될 때까지 시간이 걸리므로, 결과를 얻으려면 await가 필요합니다.

2. await
response.json() 작업이 완료될 때까지 기다리는 역할을 합니다.
성공할 경우 : 파싱된 자바스크립트 객체 (예 : {message : "..."})를 반환합니다.
실패할 경우 : 에러를 발생시킵니다. response.json() 이 실패하는 대표적인 경우는
서버가 보낸 에러 응답 본문이 유효한 JSON 형식이 아닐 때입니다.
(예 : 단순 텍스트 Internal Server Error 이거나, HTML 에러 페이지일 경우)

3.   .catch(() => ({message: '서버와 통신에 실패했습니다.'}) )
이 부분이 바로 안전장치(Fullback) 입니다. 이 코드는 response.json() 이 실패했을 때만 실행됩니다.
catch() 는 response.json() 이 던진 에러를 가로챕니다.
() => ({message: '...'})
에러를 가로챈 후, 미리 정의된 새로운 객체
{message: '서버와 통신에 실패했습니다.'} 를 반환합니다.
이렇게 하면, 서버가 어떤 형태로 에러를 반환하든 우리 프로그램은 항상
{message: "..."} 라는 일관된 형태의 에러 객체를 갖게 되어 후속 처리가 매우 쉬워집니다

4. const errorData =...
위 과정의 최종 결과가 errorData라는 상수에 저장됩니다.

시나리오 별 흐름 요약
이 코드가 어떻게 동작하는지 두 가지 시나리오로 나누어 볼 수 있습니다.

시나리오 1 : 서버가 친절하게 JSON 형식으로 에러 정보를 보내준 경우
1. response.json() 이 호출되고, 본문(예 : "message" : "권한이 없습니다.")을 성공적으로 파싱합니다.
2. await 가 파싱한 객체 {message : "권한이 없습니다."}  를 반환합니다.
3. 파싱이 성공햇으므로 .catch() 부분은 실행되지 않고 건너뜁니다.
4. errorData 상수에는 {message : "권한이 없습니다."} 가 저장됩니다.

시나리오2 : 서버가 JSON이 아닌 다른 형식(예 : 일반 텍스트) 으로 에러를 보낸 경우
1. response.json() 이 호출되지만, 본문(예 : "500-Server Error")이 JSON이 아니라서
파싱에 실패하고 에러를 던집니다.
2. response.json() 의 프로미스가 거부(reject) 되면서 .catch() 블록이 실행됩니다.
3. .catch()는 미리 준비된 객체 {message : '서버와 통신에 실패했습니다.'}를 반환합니다.
4. errorData 상수에는 {message : "권한이 없습니다"} 저장됩니다



/**
 * 서버 API 호출을 위한 헬퍼(도우미) 함수
 * @param {string} url - 요청을 보낼 서버의 URL 주소
 * @param {object} [options] - fetch 함수에 전달할 추가 옵션 객체 (예: method, headers, body 등)
 * @returns {Promise<any>} 성공 시에는 JSON으로 변환된 응답 객체를, 실패 시에는 에러를 발생시키는 프로미스(Promise)를 반환
 */
async function fetchHelper(url, options) {
    // 1. fetch API를 사용해 실제 네트워크 요청을 보내고, 서버의 응답이 올 때까지 기다립니다.
    const response = await fetch(url, options);

    // 2. 서버 응답의 성공 여부를 확인합니다. (HTTP 상태 코드가 200-299 범위가 아니면 'ok'는 false가 됩니다.)
    if (!response.ok) {
        // 3. 응답이 실패한 경우, 서버가 보낸 에러 메시지(JSON 형태)를 파싱하려고 시도합니다.
        const errorData = await response.json()
            // 만약 서버 에러 메시지가 JSON 형태가 아니라서 파싱에 실패하면, 일반적인 에러 메시지를 대신 사용합니다. (안전장치)
            .catch(() => ({ message: '서버와 통신에 실패했습니다.' }));

        // 4. 파싱한 에러 메시지나 기본 HTTP 에러 메시지를 담은 새로운 에러 객체를 생성하여 던집니다(throw).
        // 이 에러는 이 함수를 호출한 쪽의 .catch() 블록에서 잡을 수 있습니다.
        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
    }

    // 5. 성공 응답 중에서도 내용(body)이 없는 경우를 특별히 처리합니다. (예: 삭제 요청 후 '204 No Content' 응답)
    if (response.status === 204 || response.headers.get("content-length") === "0") {
        // 내용이 없으므로 null을 반환하여, 호출한 쪽에서 불필요한 JSON 파싱을 시도하지 않도록 합니다.
        return null;
    }

    // 6. 성공 응답에 내용(body)이 있는 경우, 응답을 JSON 형태로 변환하여 반환합니다.
    return response.json();
}```

---

### 상세 해석

이 `fetchHelper` 함수는 자바스크립트의 내장 `fetch` 함수를 한 단계 감싸서 더 편리하고 안전하게 사용할 수 있도록 만든
 **유틸리티(Utility) 또는 헬퍼(Helper) 함수**입니다. `fetch`를 그냥 사용할 때
 반복적으로 작성해야 하는 성공/실패 처리, 데이터 변환 로직을 이 함수 안에 표준화시킨 것입니다.

#### 이 함수의 주요 역할 및 장점:

1.  **비동기 처리 간소화 (`async/await`)**
    *   `async function`으로 선언되어, 함수 내에서 `await` 키워드를 사용할 수 있습니다.
    *   `await fetch(...)`를 통해 네트워크 요청이 완료될 때까지 코드 실행을 잠시 멈추고 기다리므로,
    콜백 함수나 `.then()` 체인을 복잡하게 사용하지 않고도 코드를 동기식(순서대로)으로 작성하는 것처럼
    보이게 만들어 가독성이 매우 높아집니다.

2.  **통합된 에러 처리**
    *   `fetch` 함수는 서버가 404(Not Found)나 500(Internal Server Error) 같은 에러 코드를 반환해도
    이를 네트워크 실패로 간주하지 않고 성공으로 처리하는 특징이 있습니다.
    *   이 헬퍼 함수는 `if (!response.ok)` 조건을 통해 이러한 HTTP 에러를 명시적으로 확인합니다.
    *   에러가 발생했을 때, 많은 API는 에러 원인을 JSON 형태(예: `{"message": "권한이 없습니다."}`)로 보내줍니다.
    이 함수는 그 JSON을 해석하여 구체적인 에러 메시지를 추출하려고 시도합니다.
    *   만약 에러 응답이 JSON이 아니거나 다른 문제로 해석에 실패하더라도, `.catch()`를 통해 앱이 중단되지 않고
     일반적인 에러 메시지를 사용하도록 안전장치를 마련했습니다.
    *   최종적으로 `throw new Error(...)`를 통해 이 함수를 호출한 곳으로 에러를 전파하여,
    호출한 쪽에서 `try...catch` 구문으로 에러를 일관되게 처리할 수 있게 합니다.

3.  **내용 없는 성공 응답 처리**
    *   데이터를 삭제하는 `DELETE` 요청 등은 성공하더라도 서버에서 별도의 데이터를 보내주지 않는 경우가 많습니다.
    이때 서버는 '성공했지만 보낼 내용 없음'이라는 의미의 `204 No Content` 상태 코드를 응답합니다.
    *   만약 이런 응답에 대해 `.json()`을 호출하면 내용이 없으므로 에러가 발생합니다.
    *   이 함수는 `response.status === 204` 등을 확인하여 이런 경우를 미리 감지하고 `null`을 반환함으로써,
    불필요한 에러를 방지합니다.

4.  **성공 데이터 자동 변환**
    *   성공적인 응답(200 OK 등)이면서 내용이 있는 경우, `response.json()`을 호출하여
    응답 스트림을 JSON 객체로 자동 변환해 줍니다.
    *   따라서 이 함수를 사용하는 쪽에서는 복잡한 변환 과정 없이 바로 데이터를 받아 사용할 수 있습니다.

**결론적으로, 이 `fetchHelper`는 서버 API를 호출할 때 발생하는 거의 모든 경우의 수(성공, 실패, 내용 없는 성공)를
미리 고려하여 처리해주는 매우 견고하고 재사용성 높은 코드 블록입니다.**




/**
 * 서버에서 투두(To-do) 목록을 가져와 화면에 렌더링하는 함수
 * @param {string} [filter='all'] - 목록을 필터링할 종류. 기본값은 'all'이며, 'incomplete', 'completed'를 사용할 수 있습니다.
 */
function fetchTodos(filter = 'all') {
    // 1. 요청을 보낼 URL을 준비합니다. 기본적으로 전체 목록을 가져오는 URL을 사용합니다.
    let url = API_URL;

    // 2. 만약 필터(filter) 값에 따라 요청 URL을 동적으로 변경합니다.
    if (filter === 'incomplete') {
        // 필터가 '미완료'이면, 미완료 목록을 요청하는 주소로 변경합니다.
        url = `${API_URL}/incomplete`;
    } else if (filter === 'completed') {
        // 필터가 '완료'이면, 완료 목록을 요청하는 주소로 변경합니다.
        url = `${API_URL}/completed`;
    }

    // 3. 앞서 만든 fetchHelper 함수를 사용하여 해당 URL로 데이터 요청을 시작합니다.
    // fetchHelper는 프로미스(Promise)를 반환하므로 .then()과 .catch()로 후속 처리를 합니다.
    fetchHelper(url)
        // 4. 요청이 성공했을 때 실행되는 부분 (Promise의 then 체인)
        .then(todos => { // todos 매개변수에는 서버로부터 받은 할 일 목록 배열이 들어옵니다.

            // 4-1. 새로운 목록을 표시하기 전에, 현재 화면에 있는 목록을 모두 지웁니다 (초기화).
            // 이렇게 하지 않으면 목록을 새로고침할 때마다 항목이 계속 중복으로 쌓이게 됩니다.
            todoList.innerHTML = '';

            // 4-2. 서버에서 받아온 'todos' 배열의 각 'todo' 항목을 순회하면서,
            // 화면에 할 일 항목을 하나씩 추가하는 함수(addTodoToList)를 호출합니다.
            todos.forEach(todo => addTodoToList(todo));
        })
        // 5. 요청이 실패했을 때 실행되는 부분 (Promise의 catch 체인)
        .catch(error => { // error 매개변수에는 fetchHelper에서 throw한 에러 객체가 들어옵니다.

            // 5-1. 개발자가 문제를 파악할 수 있도록 브라우저 콘솔에 에러를 출력합니다.
            console.error('투두리스트 로딩 오류:', error);

            // 5-2. 사용자에게 문제가 발생했음을 알림창으로 알려줍니다.
            // error.message를 통해 서버가 보낸 구체적인 에러 메시지를 보여줄 수 있습니다.
            alert(`목록을 불러오지 못했습니다: ${error.message}`);
        });
}



/**
 * 투두(To-do) 객체 하나를 받아 LI 태그로 만들어 목록에 추가하는 함수
 * @param {object} todo - 서버로부터 받은 투두 데이터 객체. {id, title, completed} 형태를 가집니다.
 */
function addTodoToList(todo) {
    // 1. 새로운 <li> (리스트 아이템) HTML 요소를 자바스크립트로 생성합니다.
    const li = document.createElement('li');

    // 2. 생성된 <li>에 'data-id'라는 특별한 속성을 추가하고, 투두 객체의 고유 ID 값을 저장합니다.
    //    이 ID는 나중에 수정/삭제 버튼을 눌렀을 때 어떤 항목을 처리할지 식별하는 데 사용됩니다.
    li.dataset.id = todo.id;

    // 3. 투두의 완료 여부(todo.completed)에 따라 <li> 요소의 클래스를 설정합니다. (삼항 연산자 사용)
    //    - true이면 'completed' 클래스를 부여하여 CSS로 취소선 등의 스타일을 적용할 수 있게 합니다.
    //    - false이면 아무 클래스도 주지 않습니다.
    li.className = todo.completed ? 'completed' : '';

    // 4. 할 일의 텍스트 내용을 담을 <span> 요소를 생성합니다.
    const todoText = document.createElement('span');

    // 5. 이 <span>에 'todo-text'라는 클래스를 부여하여 CSS로 스타일을 지정할 수 있게 합니다.
    todoText.className = 'todo-text';

    // 6. <span>의 실제 텍스트 내용으로 투두 객체의 제목(todo.title)을 설정합니다.
    //    (innerHTML 대신 textContent를 사용하면 HTML 태그가 그대로 문자로 입력되어 더 안전합니다.)
    todoText.textContent = todo.title;

    // 7. 만약 투두가 이미 완료된 상태라면, 텍스트(<span>)에도 'completed-text' 클래스를 추가합니다.
    //    (예: 텍스트 색상을 회색으로 변경하는 등 더 세부적인 스타일링을 위해)
    if (todo.completed) {
        todoText.classList.add('completed-text');
    }

    // 8. 완료, 수정, 삭제 등의 버튼들을 담을 컨테이너(container) 역할을 할 <div>를 생성합니다.
    const actionButtons = document.createElement('div');

    // 9. 이 <div>에 'action-buttons' 클래스를 부여하여 버튼 그룹의 레이아웃(정렬 등)을 잡습니다.
    actionButtons.className = 'action-buttons';

    // (이 아래에는 아마도 실제 버튼들을 생성하고 이 div에 추가하는 코드가 이어질 것입니다.)
}


/*
DOMCContedntLoaded 이벤트는 HTML 문서가 완전히 로드되고 파싱되었을 때 발생합니다.
스크립트가 HTML 요소에 접근하기 전에 실행되는 것을 방지하기 위해 이 이벤트 리스너 안에 모든 코드를 작성합니다.
*/
document.addEventListener('DOMContedtLoaded', () => {
    // 1. DOM 요소 가져오기
    // HTML에서 id를 이용해 필요한 요소들을 가져와 상수로 저장합니다.
    const todoInput = document.getElementById('todo-input');
    const addButton = document.getElementById('add-button');
    const todoList = document.getElementById('todo-list;);
    const showAllBtn = document.getElementById('show-all');
    const showIncompleteBtn = document.getElementById('show-incomplete');
    const showCompletedBtn = document.getElementById('show-completed');

    // 2. API URL 설정
    // 백엔드 서버의 API 주소를 상수로 정의합니다.
    const API_URL = 'http://localhost:8080/api/todos';

    // 3. 초기 투두리스트 불러오기 및 필터링 기능
    // 서버에서 투두리스트 데이터를 가져와 화면에 표시하는 함수입니다.
    // filter 매개변수에 따라 URL을 변경하여 특정 상태의 목록만 가져올 수 있습니다.
    function fetchTodos(filter = 'all') {
        let url = API_URL; // 기본값은 모든 목록을 가져오는 URL입니다.
        if (filter === 'incomplete') {
            url = '${API_URL}/incomplete'; // 미완료 목록을 가져오는 URL
        } else if (filter === 'completed') {
            url = '${API_URL}/completed'; // 완료 목록을 가져오는 URL
        }

        // fetch API를 사용해 서버에 GET요청을 보냅니다
        fetch(url)
            .then(response => response.json()) // 응답을 JSON 형태로 변환합니다.
            .then(todos => {
                todoList.innerHTML = ''; // 기존 목록을 모두 비웁니다.
                // 가져온 각 투두 항목에 대해 addTodoToList 함수를 실행합니다.
                todos.forEach(todo => {
                    addTodoToList(todo);
                });
            })
            .catch(error => console.error('Error fetching todos:', error));
            // 오류 발생 시 콘솔에 출력합니다

    // 투두(todo) 객체를 받아 DOM에 새로운 목록 아이템을 추가하는 함수
    function addTodoToList(todo) {
        // <li> 요소를 생성하고, 할 일 아이템의 고유 ID를 dataset에 저장합니다.
        const li = document.createElement('li');
        li.dataset.id = todo.id;
        // 할 일의 완료 상태에 따라 'comnpleted' 클래스를 추가합니다.
        li.className = todo.completed ? 'completed' : '';

        // 할 일의 텍스트를 담을 <span> 요소를 생성합니다.
        const todoText = document.createElement('span');
        todoText.className = 'todo-text';
        // 만약 할 일이 완료되었다면 텍스트에 완료 스타일 클래스를 추가합니다.
        if (todo.completed) {
            todoText.classList.add('completed-text');
        }
        // 투두 객체의 제목(title)을 텍스트 내용으로 설정합니다.
        todoText.textContent = todo.title;

        // '수정', '완료', '삭제' 버튼을 담을 <div> 요소를 생성합니다.
        const actionButtons = document.createElement('div');
        actionButtons.className = 'action-buttons';

        // 수정 버튼을 생성합니다.
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-btn';
        editBtn.textContent = '수정';

        // 완료/미완료 상태를 전환하는 버튼을 생성합니다.
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-btn';
        // 할 일의 완료 상태에 따라 버튼의 텍스트를 '미완료' 또는 '완료'로 설정합니다.
        toggleBtn.textContent = todo.completed ? '미완료' : '완료'

        // 삭제 버튼을 생성합니다.
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = '삭제';

        // 생성한 버튼들을 actionButtons <div> 안에 추가합니다.
        actionButtons.appendChild(editBtn);
        actionButtons.appendChild(toggleBtn);
        actionButtons.appendChild(deleteBtn);

        // 텍스트와 버튼 그룹을 <li>요소에 추가합니다.
        li.appendChild(todoText);
        li.appendChild(actionButtons);
        // 완성된 <li> 요소를 최종적으로 할 일 목록(todoList)에 추가합니다
        todo List.appendChild(li);

        // 이벤트 리스터 추가
        // 수정 버튼 클릭 시 editTodo 함수를 호출합니다.
        editBtn.addEventListener('click', () => editTodo(todo, li, todoText, actionButtons));
        // 완료/미완료 버튼 클릭 시 toggleTodo 함수를 호출합니다.
        toggleBtn.addEventListener('click', () => toggleTodo(todo, li, todoText, toggleBtn));
        // 삭제 버튼 클릭 시 deleteTodo 함수를 호출합니다.
    }     deleteBtn.addEventListener('click', () => deleteTodo(todo.id, li));





)













해설
document.addEventListener('DOMContentLoaded', () => {

document
객체 : 웹 페이지 자체를 나타내는 객체입니다. 이 객체를 통해 html 문서의 모든 요소에 접근하고
조작할 수 있습니다.
document 는 DOM(Document Object Model)의 최상위 객체로, 브라우저가 HTML 파일을
읽어들여 생성하는 문서의 모든 내용을 담고 있습니다.
.addEventListener()
메서드:document 객체가 가지고 있는 함수입니다. 특정 이벤트가 발생했을 때 지정된 함수를
실행하도록 '이벤트 리스너(Event Listener)'를 등록하는 역할을 합니다.
addEventListener는 두 개의 인자를 받습니다.
첫 번째 인자 : 어떤 이벤트를 감지할지 지정하는 이벤트 이름(문자열)입니다.
두 번째 인자 : 이벤트가 발생했을 때 실행할 함수입니다.

'DOMContentLoaded'
이벤트 이름 : addEventListener 의 첫번재 인자로 전달된 문자열 입니다.
이 이벤트는 HTML문서가 완전히 로드되고, 모든 DOM트리가 구성되었을 때 발생합니다.
즉, 페이지에 있는 모든 HTML요소(버튼, 입력창, 목록 등)들이 JavaScript로 조작 가능한 상태가
되었음을 의미합니다.
주의점 : DOMContentLoaded 는 <body>태그와 내부 요소들이 로드되면 바로 발생합니다.
반면에, load 이벤트는 CSS,이미지,스크립트 파일 등 모든 외부 리소스까지 완전히 로드된 후에
발생합니다.
일반적으로 DOM요소 조작만 필요할 때는 DOMContentLoaded를 사용하는 것이 더 빠르고 효율적입니다.
() => {...}
콜백 함수 : addEventListener의 두 번째 인자로 전달된 함수입니다.
이것은 화살표 함수 (Arrow Function)문법으로, function() {...}와 같은 역할을 합니다.
이벤트 리스너에 등록된 함수를 '콜벡(Callback)함수'라고 부르는데, 이는 특정 이벤트가
발생했을 때 나중에 호출(call back) 될 함수라는 의미입니다.
중괄호{} 안에는 DOMContentLoaded 이벤트가 발생했을 때 실제로 실행될 JavaScript코드들이
들어갑니다.
종합정리
document.addEventListener('DOMContentLoaded', () => {...}); 는
HTML문서가 완전히 준비되면, 중괄호{} 안의 모든 코드를 실행해라  는 의미로 해석할 수 있습니다.

따라서 투두리스트 코드에서는 이 구문 안에 모든 기능(fetchTodos, addTodoToList 등)을 작성하여,
페이지의 HTML 요소들이 모두 준비된 후에만 JavaScript가 실행되도록 만든 것입니다.
이 덕분에 스크립트가 존재하지 않는 요소를 조작하려다 발생하는 오류를 방지할 수 있습니다.


const todoInput = document.getElementById('todo-input');

const
키워드 : JavaScript 에서 변수를 선언할 때 사용하는 키워드입니다.
의미 : const는 상수(constant)를 의미합니다. 즉, 이 키워드로 선언된 변수에는
한 번 값을 할당하면 그 값을 변경(재할당)할 수 없습니다.
 이 코드에서는 todoInput이라는
변수에 DOM 요소를 할당하고,
이 변수가 다른 값을 가리키지 않도록 고정하는 역할을 합니다.

todoInput
변수이름 : 직접 정하는 이름
의미 : 이 변수는 HTML 문서에 있는 특정 요소를 가리키는 역할을 합니다.
관례적으로 어떤 역할을 하는지 알기 쉽게 이름을 짓는 것이 좋습니다.
여기서는 '투두(할 일)'를 입력(input)받는 요소라는 의미로 todoInput 이라고 지었습니다.

=
할당 연산자 : 오른쪽에 있는 값을 왼쪽에 있는 변수에 할당하는 역할을 합니다.

document
객체 : 웹 페이지 자체를 나타내는 객체입니다.
이 객체를 통해 HTML 문서의 모든 요소에 접근하고 조작할 수 있습니다.
DOM(Document Object Model) 의 최상위 객체로, 브라우저가 HTML 파일을 읽어들여 생성하는
문서의 모든 내용을 담고 있습니다.

.getElementById()
메서드 : document 객체가 가지고 있는 함수입니다.
역할 : 이 메서드는 괄호() 안에 전달된 문자열과 동일한 id 속성을 가진 HTML 요소를 찾아서
반환합니다. 만약 해당하는 요소가 없으면 null을 반환합니다.

('todo-input')
인자 : getElementById() 메서드에 전달되는 값입니다.
의미 : 이 메서드는 id가 todo-input 인 HTML 요소를 찾으라는 명령을 수행합니다.

종합 정리
const todoInput = document.getElementById('todo-input');
이 코드는 한 줄로 다음과 같은 의미를 가집니다.

HTML 문서에서 id가 todo-input 인 요소를 찾아서, 그 요소를 todoInput 이라는 이름의 상수에
할당해라.

결과적으로, 이 코드를 실행하면 todoInput 이라는 변수는 <input type="text" id="todo-input">
와 같은 HTML 요소를 가리키게 됩니다.
이제 여러분은 이 todoInput 변수를 통해 해당 입력창의 값(todoInput.value)을 가져오거나,
다른 속성을 변경하는 등 다양한 작업을 할 수 있습니다.



DOM(Document Object Model)
DOM은 Document Object Model 의 약자로, 웹 페이지를 구조화된 객체 형태로 나타낸 모델입니다.
쉽게 말해, 웹 페이지를 구성하는 모든 요소(태그, 속성, 내용 등)를 트리(tree)형태의 객체 구조로 만들어서
JavaScript 같은 프로그래밍 언어가 이 요소들에 접근하고 조작할 수 있도록 해주는 역할을 합니다.

예를들어, HTML 코드가 아래와 같을 경우
<body>
    <div id="container">
        <h1>투두리스트</h1>
        <button>추가</button>
    </div>
</body>

이 HTML 코드는 브라우저에 의해 DOM 이라는 아래와 같은 트리 구조로 변환됩니다,.
document(최상위 객체)
    html
        head
        body
            div(id : 'container')
                h1 (텍스트 : '투두리스트')
                button (텍스트 : '추가')

이렇게 객체화된 덕분에, JavaScript 코드로 h1 태그의 내용을 바꾸거나,
button을 클릭했을 때 특정 동작을 실행하는 등의 작업을 할 수 있습니다.

DOMContentLoaded
DOMContentloaded 는 HTML 문서의 로딩이 완료되었을 때 발생하는 이벤트입니다.

웹 브라우저가 HTML파일을 읽고 모든 요소들을 DOM트리로 변환하는 과정이 끝나면,
바로 이 DOMContentLoaded 이벤트가 발생합니다.

이 이벤트가 중요한 이유는 다음과 같습니다.

요소 조작의 안정성 : JavaScript코드가 HTML 요소를 조작하려면, 그 요소가 먼저 DOM트리에 존재해야
합니다.
만약 DOM이 완성되기 전에 코드가 실행되면, 원하는 요소를 찾지 못해 오류가 발생할 수 있습니다.

document.addEventListener('DOMContentLoaded', () => {...});
코드는 이 이벤트를 감지하여 HTML문서가 준비된 후에야 비로소 중괄호{} 안의 JavaScript코드를 실행하도록
보장해줍니다.

즉, 페이지의 HTML구조가 모두 만들어졌으니 이제 JavaScript로 이 구조를 조작해도 안전하다
는 신호와 같습니다.

헷갈릴 수 있는 다른 이벤트로는 load 이벤트가 있는데, 이는 HTML뿐만 아니라 페이지에 있는 모든
리소스(이미지, CSS, 다른 스크립트 파일 등) 까지 완전히 로딩된 후에 발생합니다.
보통은 HTML 요소 조작만 필요하므로 DOMContentLoaded 를 사용하는 것이 더 빠르고 효율적입니다.



function fetchTodos(filter = 'all') {
}

문법적 요소 해설
function
키워드 : JavaScript 에서 함수를 선언할 때 사용하는 키워드입니다.
함수는 특정 작업을 수행하는 코드 불록을 의미합니다.

fetchTodos
함수 이름 : 직접 정하는 이름입니다.
의미 : 이 함수가 어떤 역할을 하는지 나타냅니다.
fetch(가져오다)와 Todos(할 일들)가 결합되어 있어
"할 일 목록을 가져오는 함수"라는 것을 명확하게 알 수 있습니다.

(filter = 'all')
매개변수(Parameter) : 함수가 호출될 때 외부로부터 전달받는 값입니다.
여기서는 filter라는 이름의 매개변수를 받습니다.
= : 매개변수에 기본값(Default Value)을 할당하는 문법입니다.
'all' : filter 매개변수에 할당된 기본값입니다.

종합정리
function fetchTodos(filter = 'all') {
}
이 한줄은 다음과 같은 의미를 가집니다.
->
" fetchTodos 라는 이름의 함수를 선언하는데, 이 함수는 filter 라는 매개변수를 받는다.
만약 함수를 호출할 때 filter에 아무런 값을 넘겨주지 않으면, filter의 값은 자동으로 'all'이 된다.
즉, 이 함수는 다음과 같이 호출할 수 있습니다.
fetchTodos() : filter에 아무 값도 전달하지 않았으므로, filter의 값은 기본값인 'all'이 됩니다.
fetchTodos('completed') : filter에 'completed' 라는 값이 전달되었으므로, filter의 값은 'completed'가 됩니다.
이처럼 매개변수에 기본값을 설정하는 문법을 사용하면,
함수를 더 유연하게 호출할 수 있고 불필요한 오류를 줄일 수 있습니다.


let url = API_URL;
위 코드는 변수 url에 "API_URL"이라는 값을 할당(저장)하는 것입니다.

let
자바스크립트에서 변수를 선언할 때 사용하는 키워드입니다.
let으로 선언된 변수는 재할당이 가능합니다.(const는 재할당이 불가능합니다.)

url
이 변수의 이름입니다.

=
할당 연산자입니다. 오른쪽 값을 왼쪽에 있는 변수에 저장하라는 의미입니다

API_URL
일반적으로 상수(Constant) 또는 전역변수(Global Variable)의 이름입니다.
API_URL 이라는 이름만 보고도 'API 주소'라는 것을 쉽게 알 수 있습니다.
즉, "앞으로 API 주소가 필요할 때마다 url 이라는 변수를 사용해" 라는 의미로 이해하면 됩니다.


if (filter === 'incomplete')
filter 변수의 값이 'incomplete'와 같다면
url = '${API_URL}/incomplete'
url 변수에 ${API_URL}/incomplete 라는 새로운 값을 할당합니다.
이 주소는 미완료된 목록을 가져오는 API 엔드포인트가 될 것입니다.

else if(filter === 'completed') : if 문이 거짓이고, filter 변수의 값이 'completed'와 같다면
url = '${API_URL}/completed';
url 변수에 ${API_RUL}/completed 라는 새로운 값을 할당합니다.
이 주소는 완료된 목록을 가져오는 API 엔드포인트가 될 것입니다.

결론적으로, 이 코드는 사용자가 "미완료" 목록을 보고 싶어하는지, "완료"목록을 보고 싶어하는지에 따라
적절한 API 주소를 동적으로 결정하는 역할을 합니다.




// fetch API를 사용해 서버에 GET요청을 보냅니다.
// 이전에 정의된 'url' 변수에 따라 다른 주소로 요청을 보낼 수 있습니다.
fetch(url)
    // 서버로부터 응답이 오면 실행됩니다.
    // .then() 은 Promise 가 성공적으로 완료 되었을 때 실행되는 콜백 함수를 받습니다.
    .then(response => {
        // 응답(response)을 JSON 형식으로 파싱합니다.
        // 이 과정도 비동기적으로 처리되므로 또 다른 Promise를 반환합니다.
        return response.json();
    })
    // JSON 변환이 완료되면 실행됩니다.
    // 'todos' 변수에 서버에서 가져온 투주 목록(JSON 배열)이 담ㄱ비니다.
    .then(todos => {
        // todoList는 투두 목록이 표시되는 HTML 요소(예: <ul>, <ol>)입니다.
        // 기존에 화면에 있던 목록을 모두 비워줍니다.
        todoList.innerHTML = '';

        // 서버에서 가져온 'todos' 배열의 각 항목(todo)에 대해 반복 작업을 수행합니다.
        todos.fotEach(todo => {
            // 각 투두 항목을 화면에 추가하는 함수를 호출합니다.
            // 이 함수는 'todo' 객체를 받아 HTML 요소를 생성하고 todoList에 추가하는 역할
            addTodoList(todo);
        });
    });
    // fetch나 .then()  과정에서 오류가 발생하면 실행됩니다.
    // .catch()는 Promise가 실패(rejected)했을 때 실행되니다.
    .catch(error => {
        // 오류 메시지를 개발자 도구의 콘솔에 빨간색으로 출력합니다.
        console.error('Error fetching todos', error);
    });

    코드해설
    fetch(url)
    url 변수에 저장된 주소로 네트워크 요청을 보냅니다.
    fetch 함수는 비동기 작업이며,요청에 대한 응답을 받으면 Promise 객체를 반환합니다.


    .then(response => response.json())
    서버로부터 응답(response)이 오면, 그 응답을 JSON형식으로 반환합니다.
    이 작업 또한 비동기적이기 때문에 Promise를 반환합니다

    .then(todos => {...})
    JSON 변환이 완료되면, 변환된 데이터(todos)를 가지고 다음 작업을 수행합니다.

    todoList.innerHTML = '';
    화면에 그려진 기존의 투두 목록을 깨끗하게 지웁니다.
    todos.forEach(...)
    서버에서 가져온 투두 항목들(todos 배열)을 하나씩 반복하면서
    addTodoToList 라는 함수를 호출합니다.

    .catch(error => ...)
    fetch 요청이나 .then() 체인 과정에서 네트워크 오류 등 예외가 발생하면
    해당 오류를 잡아서 console.error 로 출력합니다.
    이렇게 하면 개발자가 문제를 쉽게 파악할 수 있습니다.


    fetch(url)은 웹 브라우저가 네트워크를 통해 특정 주소(URL)로 데이터를 요청하는 기능입니다.




// 지정된 URL로부터 데이터를 비동기적으로 가져옵니다.
fetch(URL)

    // 서버로부터 응답을 받으면, JSON 형식으로 파싱(변환)합니다.
    // .then() 메서드는 이전 단계가 성공적으로 완료되었을 때 실행됩니다.
    .then(response => response.json())

    // JSON 데이터 파싱이 완료되면, 'todos'라는 이름의 데이터를 받아 처리합니다.
    .then(todos => {

        // 'todoList'는 할 일 목록을 담을 HTML 요소입니다.
        // innerHTML을 비워서 기존에 있던 목록을 모두지웁니다.
        todoList.innerHTML ='';


        // 가져온 'todos' 배열을 순회하면서 각 할 일 항목에 대해 아래 코드를 실행합니다.
        todos.forEach(todo => {

            // 'addTodoToList' 함수를 호출하여 각 'todo' 항목을 화면에 추가합니다.
            addTodoToList(todo);

        });
    })

    // fetch나 .then() 과정에서 오류가 발생하면, 이 부분이 실행됩니다.
    // 콘솔에 오류 메시지를 출력하여 문제점을 알 수 있도록 합니다.
    .catch(error => console.error('Error fetching todos:' , error));


    코드 해설
    fetch(url)
    이 코드는 url 에 해당하는 주소로 네트워크 요청을 보냅니다.
    fetch는 Promise 객체를 반환하기 때문에,
    요청이 완료될 때까지 기다리지 않고 다음 줄로 넘어갑니다.

    .then(response => response.json())
    fetch 요청이 성공하면 서버로부터    응답(response) 을 받게 됩니다.
    response 객체에는 HTTP 상태코드나 헤더와 같은 정보가 포함되어 있습니다.
    이 코드에서는 응답을 바로 사용할 수 있는 JSON형식의 객체로 변환합니다.
    response.json() 역시 Promise를 반환합니다.

    .then(todos => {...})
    response.json() 과정이 성공적으로 완료되면, 변환된 JSON데이터가 todos 라는 변수로 전달됩니다.
    이 데이터는 할 일 목록이 담긴 배열 형태입니다.

    todoList.innerHTML = '';
    todoList는 할 일 목록이 표시될 HTML 요소를 의미합니다.
    새로운 데이터를 화면에 보여주기 전에,
    기존에 있던 목록을 모두 비워주는 역할을 합니다.

    todos.forEach(todo => {...});
    todos 배열의 각 항목 (todo)에 대해 반복문을 실행합니다.

    addTodoToList(todo);
    반복문이 돌면서 addTodoToList 라는 함수를 호출하고, 각 할 일 항목을 인자로 전달합니다.
    이 함수는 HTML 요소를 동적으로 만들어서 todoList 에 추가하는 역할을 할 것으로 예상할 수 있습니다.

    .catch(error => ...)
    fetch 요청을 보내거나 .then() 체인 과정에서 네트워크 문제,
    서버 오류 등의 에러가 발생했을 때 실행되는 부분입니다.

    console.error 를 사용해 콘솔에 에러 메시지를 출력하여 개발자가 어떤 문제가 발생했는지
    쉽게 알 수 잇도록 도와줍니다.



용어 해설
"비동기적" 이라는 말은
"동시에 일어나는 것 같지만 사실은 따로 진행하는 것"   입니다.

코딩에서는 보통
"작업이 완료될 때까지 기다리지 않고 다음 작업을 바로 시작하는 방식"


예 : 식당에서 주문을 할 때를 생각해보겠습니다.
동기적 방식(Synchronous)
주문을 합니다. (코드가 fetch(url)을 실행을 합니다. )
음식이 나올 때까지 아무것도 못하고 기다립니다. (코드가 응답을 기다림)
음식이 나오면, 그제야 다음 행동(식사)을 시작합니다. (코드가 .then() 블록을 실행 )

비동기적 방식 (Asynchronous)
주문을 합니다. (코드가 fetch(url)을 실행)
주문이 완료될 때까지 기다리지 않고 바로 다른 일 (물마시기, 대화하기)을 시작합니다.
(코드가 다음줄로 넘어갑니다.)
잠시 후 "주문하신 음식이 나왔습니다" 라고 알려주면, 하던 일을 멈추고 음식을 받습니다.
(서버 응답이 오면 .then()블록 실행)

코드의 fetch(url)도 마찬가지입니다.

웹사이트에서 데이터를 가져오는 작업은 인터넷 속도나 서버 상태에 따라 시간이 오래 걸릴 수
있습니다.
만약 이 작업이 끝날 때까지 컴퓨터가 아무것도 못하고 기다린다면,
웹페이지가 멈추거나 동작하지 않는 것처럼 보일 겁니다.

그래서 fetch 함수는 비동기적으로 작동해서, 데이터를 가져오는 작업을 시작하고,
그동안 다음 코드들을 실행해!   라고 컴퓨터에게 알려줍니다.

그리고 나중에 데이터가 다 도착하면
.then() 이라는 약속된 코드 블록을 실행해서 데이터를 처리합니다.

이런 방식을 사용하면 사용자는 웹페이지가 멈추지 않고 계속해서 다른 작업을 할 수 있게 됩니다.

todos.forEach(todo => {addTodoToList(todo); });
이 코드는 JavaScriptd의 배열 메서드와 화살표 함수(Arrow Function)문법을 사용해서
todos배열의 모든 항목을 처리하는 코드입니다.

1. todos.forEach(...)
todos
이 변수는 일반적으로 여러 개의 할 일 항목(todo)이 담겨있는 배열(Array)을 의미합니다.

.forEach()
forEach는 배열이 가지고 있는 내장 메서드입니다.
이 메서드는 배열 안의 각 요소를 한 번씩 순회하면서 정해진 작업을 수행할 때 사용합니다.

forEach는 인자로 함수(function)를 받습니다. 이 함수는 배열의 각 요소에 대해 한 번씩 호출됩니다.

즉, "todos배열의 모든 요소에 대해서 지정된 함수를 실행하라"라는 뜻입니다.


2. (todo => {...})
이 부분은 forEach 메서드에 전달되는 함수입니다. JavaScript ES6(ECMAScript 2015)에서
도입된 화살표 함수(Arrow Function)문법을 사용하고 있습니다.

todo : 매개변수(parameter)입니다.
forEach가 배열을 순회하면서, 각 요소를 이 todo라는 이름으로 함수에 전달해 줍니다.
배열의 첫 번째 요소는 todo가 되고, 두 번째 요소도 todo가 되는 식으로 순서대로 전달됩니다.
변수 이름은 item, t, element 등 자유롭게 정할 수 있습니다.

=> : 화살표 문법입니다.
function 키워드 대신 => 를 사용해 함수를 정의합니다.

{ addToList(todo); }
이 중관호 안에 들어있는 코드가 todo 라는 요소를 가지고 실제로 실행될 내용입니다.


3.addTodoToList(todo);
addTodoToList : 이전에 정의된 함수 이름입니다. 이 함수는 전달받은 todo 데이터를 이용해
화면에 새로운 할 일 목록을 추가하는 역할을 할 것입니다.
(todo) : addTodoToList 함수를 호출하면서, forEach 를 통해 전달받은 현재의 todo 항목을
인자로 넘겨줍니다.


종합적인 해석
todos.forEach(todo => { addTodoToList(todo); });

이 코드는 "todos라는 배열 안에 있는 각 요소를 todo 라는 이름으로 하나씩 꺼내서,
그 todo를 addTodoToList 함수에 넣어 실행해라" 라는 의미입니다.

간단히 말해, 배열에 있는 모든 할 일 항목을 하나씩 가져와서 화면에 목록으로 추가하는 작업을
수행하는 코드라고 이해하시면 됩니다.


코드 해석
.catch(...)
fetch 함수나 그 이후
.then() 체인에서 문제가 발생하면, .catch() 블록이 실행됩니다.
이 코드는 비동기 작업 중 발생한 오류를 잡아내는 역할을 합니다.


.catch(...)
.catch() : Promise 객체에 붙는 메서드입니다. fetch 같은 비동기 작업이 실패(rejected)했을 때 실행됩니다.
예를 들어,
네트워크 연결이 끊어졌을 때
요청한 URL이 존재하지 않을 때
서버가 응답을 보내주지 않을 때
.then() 블록 내부에서 예기치 않은 오류가 발생했을 때

이런 상황에서 .catch() 블록이 오류를 "잡아채서" 처리합니다.


(error => {...})
이 부분은 .catch() 메서드에 전달되는 함수입니다.
error : 비동기 작업 중 발생한 오류 정보를 담고 있는 객체입니다.
이 변수에는 어떤 종류의 오류가 발생했는지에 대한 상세 정보가 포함되어 있습니다.
변수 이름은 e 나 err 등으로 자유롭게 변경할 수 있습니다.
=> 화살표 함수 문법입니다.

console.error('Error fetching todos', error)
console.error(...)
JavaScript 에서 개발자 도구의 콘솔에 오류 메시지를 출력하는 함수입니다.
console.log() 와 비슷하지만,
error 함수를 사용하면 오류 메시지가 더 눈에 잘 띄게 빨간색으로 표시됩니다.

'Error fetching todos: ', error
콘솔에 출력될 메시지입니다.
'Error fetching todos:'  라는 문자열을 먼저 출력하고,
그 뒤에 , error 를 통해 실제 발생한 오류 객체의 내용을 함께 출력합니다.

종합적인 의미
결론적으로 이 코드는 "만약 데이터를 가져오는 비동기 작업 중에 에러가 발생하면, 그 에러를 error 라는
변수에 담아서 개발자 콘솔에 출력해라" 라는 의미입니다.

이렇게 .catch()를 사용하면 에러가 발생했을 때 프로그램이 갑자기 멈추는 것을 방지하고,
어떤 문제가 발생했는지 파악할 수 있어 디버깅에 큰 도움이 됩니다.



function addTodoToList(todo)
function addTodoToList(todo)는 javaScript에서 함수를 정의하는 구문입니다.
이 구문은 addTodoToList 라는 이름의 함수를 만들고, 이 함수가 todo라는 이름의 매개변수를 받는다는 것을 알려줍니다.

function 키워드
function : " 지금부터 함수를 만들겠다" 라고 컴퓨터에게 알려주는 키워드입니다.
함수는 특정 작업을 수행하는 코드 묶음입니다.

addTodoToList : 이 함수의 이름입니다. 함수 이름을 통해 어떤 일을 하는 함수인지 쉽게 유추할 수 있습니다.
여기서는 " 할일 목록(todo list) 에 항목을 추가(add)하는 함수" 라는 것을 알 수 있습니다.
함수 이름은 일반적으로 카멜케이스 방식으로 작성하며, 동사로 시작해서 그 함수의 역할을 명확히 표현하는 것이 좋습니다.

(todo) 매개변수
(todo) : 이 괄호 안에 있는 todo는 매개변수(parameter)입니다.
함수를 실행할 때 외부에서 전달받는 데이터가 이 todo라는 이름의 변수에 담기게 됩니다.
종합적인 의미
function addTodoToList(todo) 라는 코드는 addTodoToList 라는 이름의 함수를 선언하고, 이 함수를 호출할 때는 todo 라는 데이터(매개변수)를
받아서 처리할 수 있게 준비한다  는 뜻입니다.

const li = document.createElement('li')
이 코드는 html 요소를 새로 만드는 역할을 합니다.

코드 해석
const li = document.createElement('li');
이 코드는 크게 세 부분으로 나눌 수 있습니다.

const li
li 라는 이름의 새로운 변수를 선언합니다. const 는 이 변수의 값이 한 번 정해지면 바꿀 수 없다는 것을 의미합니다.

document : 현재 웹 페이지 전체를 나타내는 객체입니다. 웹페이지의 모든 html요소는 이 document 객체 안에 속해있습니다.

.createElement('li')
document 객체가 제공하는 메서드(method) 중 하나로, html 태그를 인자로 받아서 해당 태그에 해당하는 요소를 새로 생성합니다.
여기서는 <li> 태그를 인자로 넘겨서 <li> 요소를 만듭니다.

종합적인 의미
결론적으로 이 코드는 새로운 <li> 태그를 만들고, 그 만들어진 요소를 li라는 변수에 저장해라   라는 뜻입니다.
이렇게 만들어진 li 요소는 아직 웹 페이지에 실제로 보이지는 않습니다.
나중에 appendChild() 같은 메서드를 사용해서 기존 html 요소에 추가해야만 화면에 나타나게 됩니다.

예를 들어, <ul>태그에 li 요소를 추가하면 다음과 같이 할 수 있습니다.
const ul = document.querySelector('ul'); // ul 태그를 선택
const li = document.createElement('li'); // li 태그 생성
li.textContent = '새로운 할 일'; // li의 텍스트 설정
ul.appendChild(li); // ul의 자식으로 li 추가

li.dateset.id = todo.id;
이 코드는 HTML요소에 데이터를 저장하는 방법을 보여줍니다.

코드 해석
li "이전에 document.createElement('li')로 생성된 <li> html 요소를 가리키는 변수입니다.


actionButtons.appendChild(toggleBtn);

이 코드는 toggleBtn 이라는 버튼 요소를  actionButtons 라는 요소의 자식 으로 추가하는 역할을 합니다.

쉽게 설명하면, html페이지에 이미 있는 actionButtons 라는 상자 안에 toggleBtn 이라는 새로운 버튼을 넣는다고 생각하면 됩니다.

actionBttons: 버튼을 담을 부모(Parent) html 요소입니다.

.appendChild() : javascript 에서 DOM(document object model) 요소를 특정 요소의 마지막 자식으로 추가하는 메서드입니다

toggleBtn
actionButtons 안에 새로 추가될 자식 html 요소입니다.


editBtn.addEventListener('click', () => editTodo(todo, li, todoText, actionButtons));

이 요소는 editBtn 이라는 요소(버튼)를 클릭했을 때, 특정 함수(editTodo)를 실행하도록 설정하는 역할을 합니다.

코드 구성 요소
editBtn
'수정' 버튼을 나타내는 요소입니다.

.addEventListener('click', ... )
JavaScript 에서 특정 이벤트(여기서는 'click')가 발생했을 때,
미리 정의된 함수를 호출하도록 연결하는 메서드입니다.

() => editTodo(...)
화살표 함수(Arrow function) 문법으로, 클릭 이벤트가 발생하면 editTodo 함수를 호출하겠다는 의미입니다.

editTodo(todo, li, todoText, actionButtons)
클릭 이벤트가 발생했을 때 실제로 실행될 함수와,
이 함수에 전달되는 네 가지 인자(argument)들입니다.

todo
수정할 할 일의 데이터 객체입니다.
li
해당 할 일 항목 전체를 담고 있는 <li> 요소입니다.
todoText
할 일 내용 텍스트가 담긴 요소입니다.
actionButtons
수정, 삭제 버튼을 담고있는 컨테이너 요소입니다.

결론적으로, 이 코드는 사용자가 수정 버튼을 누르면 editTodo 함수가 실행되면서
현재 할 일 항목에 대한
모든 정보를 함수에 전달하여 할 일을 수정할 수 있도록 준비하는 과정이라고 이해하시면 됩니다.



// 수정 내용 저장 함수
// 할 일 수정 내용을 서버에 저장하는 함수
function saveTodo(todo, newTitle, li) {
    // 기존 투두 객체를 복사하고, 제목(title)만 새로운 값으로 업데이트
    const updatedTodo = {
        ...todo, // 기존 todo 객체의 모든 속성을 가져옴
        title: newTitle // title만 새로운 제목(newTitle)로 덮어씀
    };

    // 서버의 특정 할 일 항목(todo.id)에 수정된 내용을 보내는 API 요청
    fetch(`${API_URL}/${todo.id}`, {
        method : 'PUT', // 'PUT' 메서드는 기존 자원을 완전히 새로운 내용으로 교체할 때 사용
        headers: {
            'Content-Type' : 'application/json', // 보내는 데이터 형식이 JSON임을 명시
        },
        body: JSON.stringfy(updatedTodo), // 업데이트할 데이터를 JSON 문자열로 변환하여 본문에 담음
    })
    body: JSON.stringfy(updatedTodo), // 업데이트할 데이터를 JSON 문자열로 변환하여 본문에 담음
})
    .then(response => response.json()) // 서버응답을 JSON 형식으로 파싱
    .then(updatedItem => {
        // 서버에서 업데이트된 항목을 성공적으로 받으면 아래 코드 실행
        li.remove();    // 기존 html 목록 항목(li)을 화면에서 제거
        addTodoToList(updatedItem); // 서버에서 받은 최신 데이터로 새로운 항목을 다시 추가
        updateListBaseOnFilter(); // 필터 상태에 따라 화면을 최신화
    })
    .catch(error => console.error('투두를 업데이트하는 중 오류 발생:', error));
    // API 호출을 중 오류가 발생하면 콘솔에 에러 출력
}

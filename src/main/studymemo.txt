todoText.textContent = todo.title;

앞에서 만든 <span> 요소(todoText) 안에, todo 객체의 title 속성 값을 텍스트로 넣는 코드입니다.

textContent -> HTML 요소 안에 표시될 텍스트를 의미.(innerText와 비슷하지만 HTML태그는 무시하고 텍스트 그대로 넣음)

todo.title -> todo 라는 객체 안에 있는 title 이라는 속성 값

예를 들어 todo 객체가 이렇게 생겼다면
const todo = { id: 1, title: "운동하기", completed: false};

실행결과는
<span class="todo-text"> 운동하기</span>

즉, 할 일 제목을 화면에 표시하는 역할




if(todo.completed) {
        todoText.classList.add('completed-text');
}

todo.completed -> todo 객체의 완료 여부 (Boolean 값)
true 라면 완료된 일
false 라면 아직 미완료

classList.add('completed-text')
-> todoText 요소에 "completed-text" 라는 css 클래스를 추가

즉
할일이 완료된 상태라면(span에 완료 스타일을 적용) 한다는 뜻입니다.


css

.completed-text {
    text-decoration: line-through;
    color: gray;
}

결과 : 완료된 todo는 화면에서 회색 취소선이 그어진 텍스트로 보이게 됩니다.





if(todo.completed) {
todoText.classList.add('completed-text');
}

위 코드는 자바스크립트에서 특정 조건이 만족 되었을 때
html 요소의 스타일을 변경하는 로직의 일부입니다.
할 일 목록(To-Do List) 애플리케이션에서 흔히 사용되는 패턴입니다.

if(todo.completed) {
    todoText.classList.add('completed-text');
}

if(todo.completed)
todo 라는 객체(Object)에 completed 라는 속성(Property)이 있는지 확인합니다.
만약 completed 속성의 값이 true 이면 {} 안의 코드를 실행합니다.
이는 '할 일이 완료되었는가?'를 묻는 조건문입니다.

todoText.classList.add('completed-text')
todoText는 HTML요소를 가리키는 변수입니다.(예 : 특정 할 일 항목의 텍스트 부분)
classList는 해당 HTML요소가 가지고 있는 모든 CSS클래스(class)의 목록입니다.
.add('completed-text')는 이 목록에 'completed-text' 라는 새로운 클래스를 추가하는 명령어입니다.

결론적으로, 이 코드는 "만약 todo 객체의 completed 상태가 true(완료됨)이면, todoText라는 HTML 요소에 completed-text 라는
CSS 클래스를 추가하라"는 의미입니다.
이렇게 클래스를 추가하면, 미리 정의된 CSS 스타일에 따라 해당 텍스트의 모양이 바뀌게 됩니다.
(예: 취소선이 그어지거나 글자색이 회색으로 변하는 등
)





/*
특정 투두 항목을 '수정 모드'로 변경하는 함수

동작 흐름
1. 기존의 텍스트(todoText)를 입력창(<input>)으로 교체
2. 액션 버튼 영역(actionButtons)에 "저장" & "취소" 버튼을 표시
3. 입력창에 포커스를 주어 바로 수정 가능하도록 함
4. 엔터(Enter)키 -> 저장 실행 / ESC 키 -> 수정 취소
*/


function editTodo(todo, li, todoText, actionButton) {
// editTodo 라는 이름의 함수를 정의한다

// todo
// 투두 항목 하나의 데이터 객체 (예:{id: 1, title: "공부하기", completed: false})
// 즉 수정하려는 할 일(Todo)의 정보를 담고 있음

// li
// HTML 문서에서 리스트 항목<li> 요소
// 즉, 화면에 표시되는 "할 일 하나"에 해당하는 DOM 요소

// todoText
// 해당 li 안에 표시되고 있던 텍스트 노드나 텍스트가 들어있는 요소(span 등)
// 이걸 나중에 입력창<input>으로 교체하기 위해 전달받음

// actionButton
// 해당 투두 항목에서 "버튼 영역"을 담당하는 DOM 요소
// (예: [수정] [삭제] 버튼이 들어가는 컨테이너)
// 수정 모드로 바뀔 때는 이 부분에 "저장"/"취소" 버튼이 다시 들어감

// editTodo 함수는 특정 투두(todo) 객체와, 그 객체를 표현하는 HTML 요소들(li, todoText, actionButton)을 받아서,
// 해당 투두 항목을 수정 모드로 바꿔주는 역할을 한다.


    //***** 1. 새로운 입력창 생성 (기존 todo.title 값을 기본값으로 채워 넣음) *****
    const editInput = document.createElement('input');
    // const
    // 상수(재할당 불가 변수)를 선언하는 키워드
    // (editInput) 변수는 다른 값으로 바꿀 수 없지만, 그 안에 담긴 객체의 속성은 변경 가능

    // editInput
    // 새로 만든 HTML 요소 <input> 를 담을 변수 이름

    // document.createElement('input')
    // 자바스크립트에서 DOM API 를 이용해 새로운 HTML 태그 요소를 만드는 메서드
    // 'input'이라는 문자열을 넣었으므로 <input> 태그가 생성됨.
    // 이 시점에는 화면에 보이지 않고, 메모리 안에서만 존재함
    // 나중에 append, replaceChild 같은 메서드로 DOM에 추가해야 브라우저 화면에 나타남

    // editInput 이라는 변수에 새로운 <input> 입력창 요소를 만들어 담는다
    // 브라우저 메모리 안에 <Input> 태그 하나를 만든다
    // 아직 화면에 붙이지 않았으니, 바로 눈에 보이진않는다.


    editInput.type = 'text';
    // 입력타입은 텍스트

    editInput.value = todo.title;
    // 현재 투두 항목의 제목을 기본값으로 설정

    editInput.className = 'edit-input';
    // 스타일을 위한 CSS 클래스명 지정




    // 2. "저장"버튼 생성
    const saveBtn = document.createElement('button');

    saveBtn.className = 'save-btn';
    // 저장 버튼 CSS 클래스

    saveBtn.textContent = '저장'
    // 버튼에 보이는 텍스트


    // 4. 기존의 텍스트(todoText)를 입력창으로 교체
    li.replaceChild(editInput, todoText);

    // 5. 액션 버튼 영역을 비우고 -> "저장" / "취소" 버튼 삽입
    actionButtons.innerHTML = '';
    // 기존 버튼 제거

    actionButtons.append(saveBtn, cancleBtn);
    // 새 버튼 2개 추가


    // 6. 입력창에 포커스를 줘서 사용자 입력 준비
    editInput.focus();

    // 7. 키보드 이벤트 처리
    const handleKeyDown = (event) => {
    // handleKeyDown 이라는 이름의 함수를 만든다. 이 함수는 키보드 이벤트 객체 event를 받아서 실행된다.

    // (event) => {...}
    // 화살표 함수(Arrow Function) 문법
    // event는 함수가 호출될 때 전달받는 이벤트 객체를 의미
    // 예 : 키보드 이벤트가 발생하면, event.key  같은 속성으로 어떤 키가 눌렸는지 알 수 있음

        if (event.key === 'Enter') {
            // Enter 입력 시 -> 저장 실행

           // 사용자가 누른 키가 Enter 키일 경우, 아래 코드를 실행한다.

            event.preventDefault();
            // 폼 제출 등 기본 동작 방지

            saveTodo(todo.id, editInput.value);
            // 수정된 값으로 저장 함수 호출

            // saveTodo 라는 함수를 호출하면서 두 개의 인자를 전달한다

            // todo.id
            // 현재 todo(할 일) 객체의 고유 ID 값

            // editInput.value
            // 입력창(editInput)에 사용자가 입력한 텍스트값

            // saveTodo(할일ID, 수정된 텍스트);
            // 형태로 특정 할 일을 수정된 내용으로 저장하라  는 동작을 실행하는 코드

        } else if (event.key === 'Escape') {
        // 만약 사용자가 Escape(키보드의 Esc) 키를 눌렀다면 이라는 뜻

        // event.key
        // 사용자가 누른 키보드 키 값을 의미함

        // 'Escape'
        // 키보드의 ESC 키


            // Escape 입력 시 -> 수정 취소하고 목록 다시 갱신
            updateListBasedOnFilter();
            // updateListBasedOnFilter(); 함수를 실행한다.
            // 말 그대로 현재 선택된 필터 조건에 따라 할 일 목록을 갱신(업데이트) 한다 는 의미

            // 즉, 현재 적용된 필터에 맞춰  화면에 보이는 리스트를 다시 그려라     라는 코드
        }
    };
}




editInput.addEventListener('keydown', handleKeyDown);

editInput
어떤 입력창 (예 : 할 일 수정입력 필드)

.addEventListener('keydown', handleKeyDown)
입력창에서 키보드가 눌렸을 때 (keydown 이벤트), handlekeyKown 함수를 실행하라는 의미

즉,
사용자가 입력창에 키를 누르면 handleKeyDown 함수가 호출된다.

보통 이 안에서는
Enter
수정 내용 저장
Escape
수정 취소



saveBtn.addEventListener('click', () => saveTodo(todo.id, editInput.value));

saveBtn
"저장" 버튼

.addEventListener('click', ...)
버튼을 클릭했을 때 실행할 동작을 등록

() => saveTodo(todo.id, editInput.value)
화살표 함수, 클릭되면 saveTodo 함수를 호출하면서
todo.id (할 일의 고유 ID)
editInput.value (입력창에 입력된 수정된 텍스트 값)
을 전달

즉,
저장버튼을 클릭하면, 해당 할 일의 ID와 입력된 수정 내용을 saveTodo함수로 보내 저장한다



cancelBtn.addEventListener('click', () => updateListBasedOnFilter());

cancelBtn
"취소" 버튼

.addEventListener('click', ...)
취소 버튼이 클릭되었을 때 실행할 동작을 등록

() => updateListBasedOnFilter()
화살표 함수, 클릭 시
updateListBasedOnFilter() 함수를 호출

즉,
취소 버튼을 클릭하면, 현재 적용된 필터 조건에 맞춰 다시 목록을 갱신한다.

주로 수정 중이던 입력창을 닫고 원래의 할 일 목록 화면으로 되돌아가는 용도로 쓰임


/*
현재 활성화된 필터를 기준으로 목록을 업데이트하는 함수
*/
function updateListBasedOnFilter() {

    const activeFilterBtn = document.querySelector(.'.filter-container button.active');
    // .filter-container 안에서 현재 'active' 클래스를 가진 버튼을 찾아옴

    const filter = activeFitlerBtn.id.replace('show-','');
    // 버튼의 id 값에서 'show-' 부분을 제거하고 필터 이름만 추출
    // 예 : id= "show-all" -> filter="all"

    fetchTodos(filter);
    // 추출한 필터 값을 사용하여 할 일 목록을 다시 불러옴

    /*
    필터 버튼의 활성 상태를 시각적으로 변경하는 함수
    */
    function setActiveFilter(activeButton) {

        document.querySelectorAll('.filter-container button'.).forEach(btn => btn.classList.remove());
        // 모든 필터 버튼에서 'active' 클래스를 제거(초기화)

        activeButton.classList.add('active');
        // 클릭된 버튼에만 'active' 클래스를 추가 (선택된 버튼 강조)
}




const activeFilterBtn = document.querySelector('.filter-container button.active');

const activeFilterBtn
activeFilterBtn 이라는 함수를 선언 (바뀌지 않는 변수)

document.querySelector(...)
HTML문서에서 조건에 맞는 첫 번째 요소를 찾아옴

'.filter-container button.active'
CSS 선택자

.filter-container
클래스가 filter-container 인 요소

button.active
그 안에서 클래스가 active인 button 요소

즉
filter-container 안에서 active 클래스를 가진 버튼 요소를 찾아서 activeFilterBtn 에 저장한다


.querySelector(...)
.querySelector(...) 는 DOM API 메서드로, HTML 문서 안에서 특정 CSS 선택자와 일치하는 첫 번째 요소를 찾아 반환하는 기능입니다.

document
HTML 전체 문서를 가리킴

.querySelector('선택자')
지정한 CSS 선택자에 맞는 첫 번째 요소를 가져옴


('.filter-container button.active')
이 부분은 CSS 선택자입니다.

선택자 해석
.filter-container
클래스 이름이 fitler-container 인 요소

button.active
button 태그이면서 동시에 active 클래스를 가진 요소

띄어쓰기 (.filter-container  button.active)

자식/후손 관계를 의미
즉, filter-container 안에 있는 button.active

('.filter-container button.active')
filter-container 안에 있는 버튼 중, active 클래스를 가진 버튼



206

    /**
     * 현재 활성화된 필터를 기준으로 목록을 업데이트하는 함수
     */
    function updateListBasedOnFilter() {
        const activeFilterBtn = document.querySelector('.filter-container button.active');
        const filter = activeFilterBtn.id.replace('show-', '');
        fetchTodos(filter);
    }

    /**
     * 필터 버튼의 활성 상태를 시각적으로 변경하는 함수
     */
    function setActiveFilter(activeButton) {
        document.querySelectorAll('.filter-container button').forEach(btn => btn.classList.remove('active'));
        activeButton.classList.add('active');
    }



const filter = activeFilterBtn.id.replace('show-','');
버튼의 id에서 "show-" 접두어를 제거한 문자열을 filter 변수에 담는 코드
즉, 현재 어떤 필터 버튼이 눌렸는지를 문자열("all", "completed", "incompleted")로 저장하는 역할을 합니다.



activeFilterBtn.id
activeFilterBtn 이라는 버튼 요소의 id 속성을 가져옵니다.

.replace('show','')
문자열에서 show-  라는 부분을 빈 문자열 ''  로 바꿉니다.
즉, "show-" 접두어를 제거하는 동작입니다.

예시
"show-all".replace('show-','') -> "all"
"show-completed".replace('show-', '')

const filter = ...
이렇게 처리된 결과 문자열을 filter 변수에 저장합니다.



fetchTodos(filter);
현재 선택된 필터 기준   으로 할 일 목록을 가져오는 함수를 실행하는 코드
filter 가 "all" -> 모든 할 일 불러오기



fetchTodos
정의해둔 함수 이름
할 일 목록(Todos)을 가져오는 역할을 합니다.


(filter)
앞서 만든 filter 변수를 함수의 인자로 전달합니다.
filter 값은 "all", "completed", "incompleted" 중 하나
이 값에 따라 어떤 Todo 목록을 불러올지 결정



function setActiveFilter(activeButton) {
}
setActiveFilter 라는 이름의 함수를 정의하는데,
이 함수는 클릭된 버튼(activeButton)을 기준으로 현재 활성화된 필터를 설정하는 역할을 합니다.




function
새로운 함수를 정의할 때 사용하는 키워드

setActiveFilter
함수 이름
직역하면  활성화된 필터를 설정한다  라는 의미
보통UI 에서 어떤 필터 버튼이 선택되었는지 표시하거나,
선택된 버튼에 맞게 동작을 바꾸는 역할을 합니다.

(activeButton)
-> 이 함수가 받을 매개변수(parameter)
activeButton 은 사용자가 클릭한 필터 버튼 요소 (예 : show-all, show-completed, show-incomplete 버튼 중 하나)를
의미합니다.





document.querySelectorAll('.filter-container button')
    .forEach(btn => btn.classList.remove('active'));


1. document.querySelectorAll('.filter-container button')

document.querySelectotAll(...)
html문서에서 특정 선택자(selector) 에 해당하는 모든 요소를 선택합니다.

.filter-container button
.filter-container 라는 클래스 안에 있는 모든 버튼(button)요소를 선택한다는 뜻

즉,
필터 버튼 전체를 가져오는 코드입니다.



function setActiveFilter(activeButton) {
}
setActiveFilter 라는 이름의 함수를 정의하는 구문
setActiveFilter 함수이름(필터 버튼을 활성화시키는 역할을 의미)
activeButton
함수에 전달되는 매개변수(parameter), 즉 "현재 활성화시킬 버튼 요소"를 의미
-> 즉, 전달받은 버튼을 활성화 상태로 설정하는 함수의 시작 부분 이라는 뜻


document.querySelectorAll('.filter-container button').forEach(btn => btn.classList.remove('active'));

의미는
".filter-container 안에 있는 모든 버튼 요소를 찾아서, 각각의 버튼에서 'active'라는 클래스를 제거한다"  입니다.


document.querySelectorAll('.filter-container button')
-> HTML 문서에서 .filter-container 라는 클래스를 가진 요소 안의 모든 <button> 태그를 선택

.forEach(...)
선택된 버튼들을 하나씩 순회

btn.classList.remove('active')
각 버튼의 class 목록에서 'active' 클래스를 제거

btn.classList.remove('active')
버튼(btn) 요소의 클래스 목록에서 'active' 라는 클래스를 제거한다.
btn
-> 반복문(forEach)에서 순회 중인 버튼 요소
.classList
해당 요소의 class 속성을 제어할 수 있는 객체
.remove('active')
클래스 목록에서 'active'를 삭제
버튼이 활성화 표시(선택 상태) 되어 있었다면 그 표시를 없애는 것입니다.
모든 버튼의 활성화 상태를 초기화한 뒤 -> 선택된 버튼만 다시 add('active')로 활성화하기 위해서입니다.

즉, 기존에 활성화돼 있던 버튼의 'active'상태를 모두 초기화하는 과정입니다.


activeButton.classList.add('active');
activeButton으로 전달된 버튼에 'active' 클래스를 추가한다 입니다

activeButton
함수 매개변수로 받은 "클릭된(또는 활성화하려는) 버튼" 요소

.classList.add('active')
해당 버튼의 class 속성에 'active'라는 이름의 CSS 클래스를 추가

즉,
방금 전의 모든 버튼에서 'active' 클래스를 제거했다가,
선택된 버튼에만 'active'클래스를 붙여서 활성화 표시를 해주는 것



addButton.addEventListener('click',handleAddTodo);
addButton(추가 버튼) 을 클릭했을 때 handleAddTodo 함수를 실행하도록 이벤트를 등록한다.

addButton
HTML에서 id="add-button" 같은 식으로 선택된  추가 버튼 요소

.addEventListener('click', ...)
이 버튼에 클릭 이벤트 리스너를 붙임

handleAddTodo
클릭 시 실행할 함수(할 일을 추가하는 기능 담당)

즉, 버튼을 누르면 할 일이 리스트에 추가되는 로직(handleAddTodo 함수)이 실행됨


todoInput.addEventListener('keypress', (event) => {     )
todoInput(할 일 입력창)에서 키보드가 눌릴 때마다 event 를 전달받아 실행되는 함수를 등록한다

todoInput -> <input> 입력창 요소 ( 예: id="todo-input" )
.addEventListener('keypress', )
입력창에서 키가 눌렸을 때 발생하는 이벤트(keypress)를 감지

(event) => {...}
화살표 함수, 눌린 키에 대한 정보를 event 객체로 받아옴

즉, 사용자가 입력창에서 키보드를 누를 때 실행되는 동작을 정의하는 부분

보통 이 안에서 Enter 키를 눌렀는지 확인하고, Enter 라면 새로운 할 일을 추가하는 코드가 들어간다


if(event.key === 'Enter') handleAddTodo();

사용자가 누른 키 (event.key) 가 "Enter"라면 handleAddTodo() 함수를 실행한다

event.key
지금 눌린 키의 이름 (예 : "a","1","Enter")

=== 'Enter'
눌린 키가 Enter 인지 확인하는 조건문

handleAddTodo();
조건이 참일 때 실행, 즉 할 일을 추가하는 함수 실행

->
즉, 입력창에서 Enter를 누르면 버튼 클릭 없이도 새 할 일이 추가되도록 동작하는 것입니디ㅏ.

요약:
버튼을 누르거나 Enter를 치면 같은 기능 (handleAddTodo)이 실행되도록 만든 것입니다.



btn.classList.remove('active')
버튼(btn) 요소의 클래스 목록에서 'active'라는 클래스를 제거한다
btn
반복문(forEach)에서 순회 중인 버튼 요소
.classList
해당 요소의 class 속성을 제어할 수 있는 객체
.remove('active')
클래스 목록에서 'active'를 삭제

즉
버튼이 활성화 표시(선택 상태) 되어 있었다면 그 표시를 없애는 것

이게 실행되는 이유는,
모든 버튼의 활성화 상태를 초기화한 뒤
선택된 버튼만 다시
add('active')로 활성화하기 위해서





filterContainer.addEventListener('click',(event) => {
)

filterContainer 요소에 클릭 이벤트 리스너를 등록한다는 뜻
즉, 사용자가 filterContainer (예 : 버튼들이 들어있는 컨테이너 같은 DOM 요소)를 클릭했을 때,
뒤에 오는 함수 ( (event) => {...} ) 가 실행하도록 설정한 것

(event) 는 클릭 이벤트가 발생했을 때의 이벤트 객체를 의미

{...} 안에는 클릭시 실행할 코드들이 들어감

쉽게 말하면
filterContainer 를 클릭하면 이 안의 코드를 실행하라


const clickedButoon = event.target.closest('button');

event.target
사용자가 실제로 클릭한 DOM 요소를 뜻합니다.

.closest('butoon')
클릭된 요소에서 가장 가까운 button 태그를 찾아 반환합니다.
만약 클릭한 곳이 버튼 안의 <span> 같은 자식 요소라면, 그 부모인 <button>을 찾아줍니다.
버튼이 아니면 null을 반환합니다.
즉,
사용자가 클릭한 위치에서 가장 가까운 <button> 요소를 찾아 clickedButton 변수에 저장한다.



if(!clickedButton) return;
클릭한 요소가 버튼이 아니면 함수를 실행하지 말고 바로 종료해라

!clickedButton
clickedButton 이 없다 (null 또는 undefined다) 는 뜻

즉, 사용자가 클릭한 곳이 버튼이 아니라면 true가 됩니다.

return;
그냥 함수 실행을 멈추고 빠져나간다는 의미

클릭한 요소가 버튼이 아니면 함수를 실행하지 말고 바로 종료해라

즉, 버튼 외의 영역(예: 빈 공간, 텍스트 등)을 클릭했을 때는 이벤트가 무시되도록 하는 안전 장치



const filter = clickedButton.id.replace('show','');

clickedButton.id
사용자가 클릭한 버튼의 id 값을 가져옵니다.

.replace('show','')
id값에서 show- 라는 글자를 찾아서 빈 문자열 ""  로 바꿔 제거합니다.
결과를 filter 변수에 저장합니다.

예시
버튼의 id가 "show-completed" 라면 -> completed
버튼의 id가 "show-active"라면 -> "active"
버튼의 id가 "show-all"라면 -> "all"

즉,
클릭한 버튼의 id에서 show- 라는 접두사를 빼고, 나머지 부분만 filter 변수에 저장한다


filter는 어떤 할 일 목록을 보여줄지 (예: 전체, 완료됨, 진행중)를 구분하는 역할을 하게 됩니다.


setActiveFilter(clickedButton);
setActiveFilter 라는 함수를 호출하면서 사용자가 클릭한 버튼 clickedButton 을 인자로 전달합니다.




총 해석
->
1. filterContainer 클릭 감지
2. 클릭된 요소에서 가장 가까운 <button> 찾기
3. 버튼이 아니면 종료
4. 버튼의 id에서 show- 제거       ->    filter 값 추출
5. 그 버튼을 활성 버튼으로 표시



fetchTodos(filter);
fetchTodos라는 함수를 호출하면서, 앞에서 구한 filter 값을 인자로 넘깁니다.
이 함수는 보통 서버나 로컬데이터에서 할 일 목록(Todos)을 불러오되, 필터 조건에 맞게 가져오는 역할을 합니다.

filter가 "all" -> 전체 할 일 불러오기
filter가 "completed" -> 완료된 할 일만 불러오기
filter가 "active" -> 진행 중인 할 일만 불러오기

"선택된 필터 조건에 맞는 할 일 목록을 불러와서 화면에 표시해라"

정리
1.filterContainer 클릭 감지
2.클릭된 버튼 찾기 (clickedButton)
3.버튼 아니면 종료
4. 버튼id에서 "show-" 제거 -> filter 값 추출
5. 클릭된 버튼을 활성화 표시
6. filter 조건으로 할 일 목록 다시 불러오기



주석
// 필터 버튼 클릭 이벤트 등록 (이벤트 위임 방식 사용)
// filterContainer 안에서 발생하는 클릭 이벤트를 한 번만 감지하고,
// 실제 클릭된 버튼에 따라 동작을 다르게 처리합니다.
filterContainer.addEventListener('click', (event) => {

    // 사용자가 클릭한 요소에서 가장 가까운 <button> 요소를 찾음
    // (버튼 안의 <span> 같은 요소를 눌러도 해당 버튼이 인식되도록 함)
    const clickedButton = event.target.closest('button');

    // 클릭된 요소가 버튼이 아니면 함수 실행 중단
    // (즉, 버튼 영역 외 클릭은 무시)
    if(!clickedButton) return;

    // 버튼의 id 에서 "show-" 라는 접두사를 제거해 필터 이름만 추출
    // 예 : "show-completed" -> "completed"
    const filter = clickedButton.id.replace('show-', '');

    // 클릭된 버튼을 활성화 상태로 표시 (예 : CSS class "active" 추가)
    // 동시에 다른 버튼들에서는 활성화 표시 제거
    setActiveFilter(clickedButton);

    // 선택된 필터 조건에 맞는 할 일 목록 불러오기
    // 예 : "all" -> 전체, "completed" -> 완료된 항목
    fetchTodos(fitler);
});

해설(흐름 요약)
1. filterContainer(버튼들을 감싼 부모 요소)에 클릭 이벤트를 걸어둔다 (이벤트 위임 -> 버튼 개수만큼 리스너를 안 달아도 됨)
2. 실제 클릭된 요소가 버튼인지 확인한다 (버튼이 아니라면 무시)
3. 버튼id에서 "show-" 를 제거해 어떤 필터인지 (all, completed) 알아낸다
4. 클릭된 버튼을 시각적으로 활성화 표시한다
5. 해당 필터 조건에 맞춰 할 일 목록을 다시 가져온다.




const clickedButton = event.target.closest('button');

event
누가 어디를 클릭했는지 정보가 들어있는 상자

event.target
사용자가 정확히 클릭한 그 요소. (버튼 안의 글자 <span>이나 아이콘 <i> 일 수도 있다.)

.closest('button')
지금 요소에서 위로 위로(부모 방향)올라가며 가장 가까운 <button>을 찾아 준다.
자기 자신이 이미 <button> 이면 그걸 바로 돌려줍니다.
끝까지 올라가도 버튼이 없으면 null

사용자가 클릭한 곳에서 시작해, 위쪽으로 올라가며 제일 가까운 버튼 요소를 찾아 clickedButton 에 담는다


과정
1. 사용자가 클릭함 -> 브라우저가 event를 만든다
2. event.targe은 실제로 맞은 요소
예 : <span> 아이콘 </span>  같은 버튼의 자식
3. closest('button') 가 다음과 같이 움직인다
 지금 요소가 <button> 인가? -> 맞으면 그 버튼 반환
 아니면 부모로 한 칸 올라감 -> 또 <button> 인가? -> 맞으면 반환
 최상단까지 가도 못 찾으면 null 반환

 왜 이렇게 쓰나? (이벤트 위임에 딱!)
 버튼 안에는 보통 글자, 아이콘, <span>, <svg> 같은 자식 요소들이 있다.
 사람은 버튼을 눌렀지만, 실제로는 그 자식 요소를 클릭한 것으로 잡히는 경우가 많다
 closest('button')을 쓰면 무조건 버튼 본체를 안전하게 찾아낼 수 있습니다.


작은 예시
<div class = "filter-container">
    <button id ="show-all"><span>전체</span></button>
    <button id ="show-active"><i>진행중</i></button>
    <button id ="show-completed">완료</button>
</div>

전체 글자 <span>를 클릭 -> event.target 은 <span>
-> .closest('button')는 그 부모 버튼 (#show-all)을 찾아서 반환

진행중 아이콘 <i> 클릭 -> 부모 버튼 #show-active반환
버튼이 아닌 빈 공간 클릭 -> 위로 올라가도 <button>없음 -> null
-> 그래서 보통 바로 다음 줄에 if(!clickedButton) return; 같은 안전 체크를 합니다.



.target
누구를 정확히 클릭했는지 알려주는 속성
event.target = 사용자가 클릭한 진짜 요소

버튼 안에 글자 <span> 나 아이콘 <i>이 있으면, 그걸 클릭한 걸로 잡음

html
<button>
    <span>클릭</span>
</button>

<span> 글자를 클릭하면 -> event.target 은 <span>
버튼 테두리 직접 클릭하면 -> event.target 은 <button>

즉,
target은 "마우스가 실제로 맞은 그 지점 요소"


.closest('선택자')
가까운 부모 중에 이 조건(선택자)에 맞는 걸 찾아줘
지금 요소 자신부터 검사 -> 없으면 위로 올라가며(부모 방향) 검사
제일 가까운 조건 맞는 요소 반환
끝까지 없으면 null


html
<div class="box">
    <button id ="btn">
        <span>글자</span>
    </button>
</div>

js
const span = document.querySelector('span');
span.closest('button'); // <button id ="btn">...</button>
span.closest('.box');   // <div class="box">...</div>
span.closest('div');    // <div class="box">...</div>
span.closest('ul');     // null (못 찾음)

즉,
.closest() 는  "나부터 시작해 위쪽으로 올라가면서 제일 가까운 특정 태그/클래스를 찾아라"

두 개를 합치면

event.target
실제 클릭된 요소

event.target.closest('button')
클릭된 요소에서 시작해 버튼 본체를 찾는 것




todoList.addEventListener('click',(event) => {
)

todoList 라는 DOM 요소 (예 : <ul> 같은 리스트)에 클릭 이벤트 리스너를 등록하는 코드입니다.

사용자가 todoList 영역안의 어떤 부분을 클릭하면, 뒤에 정의된 화살표 함수 (event) => {...} 가 실행됩니다.

(event) 는 이벤트 객체를 받아와서, 클릭된 대상(event.target) 등과 같은 정보를 사용할 수 있게 해줍니다.

즉, todoList 영역을 클릭했을 때 실행할 동작을 지정하는 코드입니다.



js
const li = event.target.closest('li');

event.target
사용자가 실제로 클릭한 HTML 요소 (예: <span>, <button> 같은 것)

.closest('li')
클릭된 요소에서 가장 가까운 조상요소(ancestor) 중에서 <li>태그를 찾아 반환.

만약 클릭한 게 <span> 이라도, 그 <span>이 <li> 안에 있으면 해당<li>요소를 찾아줌
<li>를 찾을 수 없으면 null 반환

즉,
클릭한 요소가 속한 가장 가까운 <li>요소를 찾아서 li변수에 담는다

보통 투두리스트에서 어떤항목(li)이 클릭되었는지 찾기 위해 쓰입니다.


js
if (!li) return;

!li -> li 가 null 또는 undefined인 경우 (즉, <li> 요소를 못 찾았을 경우)

return
그 즉시 함수를 종료시켜 더 이상 실행하지 않음

즉,
"만약 클릭된 요소가 <li> 안에 속해 있지 않다면, 함수 실행을 멈추고 아무 것도 하지 않는다"

이렇게 해주면 todoList 안의 빈 영역이나 <li> 밖을 클릭했을 때 불필요한 오류나 동작이 실행되지 않게 막는 역할을 합니다.




const id = Number(li.dataset.id);
li.dataset.id   ->  <li> 요소에 있는 data-id 속성 값을 가져옴
예 : <li data-id="3"> 라면 li.dataset.id 는 "3" 문자열

Number(...)
문자열 "3" 을 숫자 3으로 변환

즉,
클릭된 <li> 요소의 data-id 값을 숫자로 변환해 id 변수에 저장한다.

보통 투두 리스트 같은 곳에서 각 항목에 고유한 id를 붙여두고,
그걸 이용해 어떤 항목을 수정하거나 삭제할지 식별할 때 사용합니다.


const id = Number(li.dataset.id);

li.dataset.id
<li> 요소에 있는 data-id 속성 값을 가져옴

예 : <li data-id="3"> 라면 li.dataset.id 는 "3" (문자열)

Number(...)
문자열 "3"을 숫자 3으로 변환

즉,
클릭된 <li> 요소의 data-id 값을 숫자로 변환해 id 변수에 저장한다

보통 투두 리스트 같은 곳에서 각 항목에 고유한 id를 붙여두고, 그걸 이용해 어떤 항목을 수정하거나 삭제할지 식별할 때 사용합니다.

const targetClass = event.target.class.Name;

event.target
사용자가 실제 클릭한 요소 (예: 버튼, 텍스트, 체크박스)

.className
그 요소에 지정된 CSS클래스 이름 전체 문자열을 가져옴

예를 들어
<button class="delete-btn">삭제</button>

이 버튼을 클릭했다면
event.target.className 의 값은 "delete-btn"이 됩니다.

즉,
"클릭된 요소의 클래스 이름을 문자열로 가져와 targetClass 변수에 저장한다

이 값은 보통
if(targetClass === 'delete=btn') {...} 처럼 조건문에서 삭제 버튼인지, 수정버튼인지 등을 구분할 때 쓰입니다.



if(targetClass === 'toggel-btn') {
}

targetClass
방금 가져온 클릭된 요소의 클래스 이름

=== 'toggle-btn'
그 클래스 이름이 "toggle-btn" 과 정확히 일치하는지 비교

즉
클릭된 요소가 toggle-btn 클래스라면, 아래에 정의된 동작을 실행한다.

보통 이 부분은 할 일 완료/미완료 상태를 전환하는 버튼을 눌렀을 때 실행되는 조건문


toggleTodo
미리 정의된 함수 이름 (할 일을 토글 (완료 <-> 미완료 전환)하는 기능 담당
(id) -> 클릭된 <li> 요소의 고유한 id 값을 인자로 전달
즉,
"해당 id를 가진 투두 항목의 상태(완료/미완료)를 바꾸는 함수를 실행한다"

예를 들어,
id = 3 이라면
toggleTodo(3) 호출
-> id가 3인 할 일의 상태를 반대로 변경



} else if (targetClass === 'delete-btn') {

해석
else of ->
앞의 조건 (toggle-btn) 이 거짓일 때, 새로운 조건을 검사

targetClass === 'delete-btn'
-> 클릭된 요소의 클래스 이름이
"delete-btn"인지 확인

즉,
클릭된 요소가 delete-btn 클래스라면, 아래에 정의된 동작을 실행한다

보통 이 구문은
toggle-btn
완료 상태 토글

delete-btn
할 일 삭제

처럼 버튼의 용도에 따라 다른 기능을 실행하도록 구분하는 역할을 합니다.




DOM 요소란?
DOM = Document Object Model
쉽게 말하면 웹 페이지의 구조를 자바스크립트가 이해하고 조작할 수 있게 만든 객체 모델

DOM 요소 = HTML 문서 안의 각 개별 요소를 의미
예 : <ul>, <li>, <button>, <div> 같은 태그 하나하나가 DOM 요소가 됩니다.

예를 들어
HTML 이 이렇게 있을 때

<ul id ="todoList">
    <li>할 일 1</li>
    <li>할 일 2</li>
</ul>

document.getElementById('todoList')
<ul> 전체를 가리킴
이것이 DOM 요소

document.querySelector('li')
첫 번째 <li>를 가리킴
이것도 DOM 요소

정리하자면
"DOM 요소" 란 자바스크립트로 접근하고 조작할 수 있는 HTML 페이지 안의 개별 태그를 의미합니다.



li.dataset.id

dataset 이란?
HTML요소의 data- 속성을 자바스크립트에서 다룰 수 있도록 제공하는 객체

예를 들어 HTML에 이렇게 작성하면
<li data-id="3"> 할 일1</li>

이 <li> 요소를 자바스크립트에서 가져오면
const li = document.querySelector('li');
console.log(li.dataset.id); // "3"

즉,
dataset을 통해  data- 로 시작하는 모든 사용자 정의 속성에 접근할 수 있습니다.


li.dataset.id 의 의미

<li> 요소에 있는 data-id 값을 가져옴

위 예제라면 "3" (문자열) 반환

필요하면 Number(li.dataset.id) 처럼 숫자로 변환해 사용 가능

정리
li.dataset.id = 클릭한 <li> 요소에 저장된 data-id 값을 가져오는 코드




todoList.addEventListener('click', (event) => {
)

todoList
"할 일 목록" 을 담고 있는 HTML 요소

.addEventListener('click', ... )
todoList 안에서 클릭(click)이벤트가 발생했을 때 실행할 코드를 등록하는 기능

(event) => {...}
이벤트가 발생했을 때 실행될 "콜백 함수"
event는 클릭에 대한 모든 정보(어떤 버튼을 눌렀는지, 좌표는 어디인지 등)를 담고 있는 객체

->
할 일 목록(todoList)안에서 클릭이 발생하면,
그 클릭 정보를 event 라는 이름으로 받아와서 {...} 안의 코드를 실행하라


const li = event.target.closest('li');

event.target
실제로 사용자가 클릭한 HTML 요소를 가리킵니다.

<button class="delete-btn">삭제</button> 버튼을 클릭했다면, event.target 은 바로 그 <button>이 됩니다


.closest('li')
클릭된 요소에서 시작해서, 가장 가까운 조상(부모 쪽)요소 중에서 'li' 태그를 찾아 반환합니다.

만약 버튼이 <li> 안에 들어 있다면, 해당<li>를 찾아서 가져옵니다.
만약 위쪽에 <li>가 전혀 없다면 null 을 반환합니다.

const li = ...
찾은 <li> 요소를 li 라는 변수에 저장합니다.

->
쉽게 말하면
사용자가 클릭한 버튼이 어떤 할 일 항목 <li> 안에 있는지 찾아서,
그 <li>를 변수 li 에 담아라


예시
<ul id="todoList">
    <li data-id="1">
        <span>공부하기</span>
        <button class="delete-btn">삭제</button>
    </li>
</ul>

여기서 "삭제" 버튼 클릭->
event.target = <button class="delete-btn">
event.target.closest('li') = <li data-id="1">...</li>



.closest('li') 는 "클릭한 요소에서 시작해서, 부모 쪽으로 올라가면서 가장 가까운 <li> 태그를 찾아라"
라는 뜻

아주 쉬운 비유
어떤 버튼(자식 요소)을 눌렀다고 하자
버튼은 <li> 태그(부모)안에 들어있다.
.closest('li')는 이렇게 말한다
"내가 속한 집(li)을 찾아줘. 제일 가까운 집(li)부터 확인할게 "


<ul>
    <li data-id="1">
        <span> 할 일 1 </span>
        <button class="delete-btn"> 삭제 </button>
    </li>
    <li data-id="2">
        <span> 할 일 2 </span>
        <button class="delete-btn"> 삭제 </button>
    </li>
</ul>


<script>
    document.addEventListener('click',(event) => {
        // 클릭된 요소(event.target) 에서 가장 가까운 <li> 찾기
        const li = event.target.closest('li');
        console.log("찾은 li:", li);
    });
</script>

실행 흐름
1. 내가 삭제 버튼(button)을 클릭하면 -> event.target 은 그 버튼이다
2. .closest('li') 를 하면 -> 그 버튼을 감싸고 있는 <li> 태그를 찾아준다.

html

<li data-id="2">
    <span>할 일 2 </span>
    <button class="delete-btn">삭제</button>
</li>

만약 클릭한 요소가 <li> 안에 없는 다른 태그라면 ->
.closest('li') 는 null 을 반환한다

한줄 요악
.closest('li')
클릭된 요소에서 시작해서, 가장 가까운 조상(부모 쪽) 요소 중에서 'li' 태그를 찾아 반환합니다.

만약 버튼이 <li> 안에 들어 있다면, 해당 <li>를 찾아서 가져옵니다.
만약 위쪽에 <li> 가 전혀 없다면 null을 반환합니다.

const li = ...
찾은 <li> 요소를 li라는 변수에 저장합니다

쉽게 말하면
사용자가 클릭한 버튼이 어떤할 일 항목<li> 안에 있는지 찾아서, 그 <li>를 변수 li 에 담아라

<ul id="todoList">
    <li data-id="1">
        <span>공부하기</span>
        <button class="delete-btn">삭제</button>
    </li>
</ul>

여기서 "삭제" 버튼 클릭
event.target = <button class="delete-btn">
event.target.closest('li') = <li data-id="1">  ... </li>



if(!li) return;

li
앞에서 찾은 <li> 요소 (없으면 null)
!li
li 가 없다(null 이다) 라는 뜻
! 부정(not)을 의미
!li 는 li가 존재 하지 않을 때  를 뜻합니다

return;
함수 실행을 즉시 종료하고, 더 이상 아래 코드를 실행하지 않음

만약
<li> 요소를 찾지 못했다면 (= 할 일 항목과 관련 없는 부분을 클릭했다면) 그냥 여기서 멈추고 아무것도 하지 마라


예시 상황
할 일 목록 바깥쪽 여백을 클릭했을 경우
event.target.closest('li') 는 null

if(!li) return;
때문에 함수 종료 -> 불필요한 코드 실행 방지

즉,
이 줄은 안전 장치 역할을 합니다.
할 일 항목(li) 내부가 아닌 곳을 클릭했을 때는 아무 동작도 하지 않게 막아주는 것이다.



const id = Number(li.dataset.id);

li.dataset
HTML 태그에 data-속성으로 저장된 값들을 가져올 수 있는 객체입니다.

예를 들어 HTML에 이런 코드가 있다고 합시다.

<li data-id="3"> 공부하기 </li>

그러면 li.dataset.id 의 값은 "3" (문자열)이 됩니다.

Number(...)
문자열을 숫자로 변환하는 함수입니다.
"3" -> 3 (문자열 -> 숫자)

const id = ...
변환된 숫자를 id 라는 변수에 저장합니다.

const id =Number(li.dataset.id);
즉
<li> 태그 안에 있는 data-id 값을 꺼내와서 숫자로 바꾼 뒤, id 변수에 저장해라

HTML

html
<li data-id="5"> 책 읽기 </li>

자바스크립트 실행

const id = Number(li.dataset.id);
console.log(id); //5 (숫자)

즉, 이 줄은 각 할 일 (todo)을 구분하기 위한 고유 번호(id)를 꺼내오는 역할을 합니다.


const targetClass = event.target.className;

event.target
사용자가 실제로 클릭한 HTML 요소 (예: 버튼)

.className
그 요소의 class 속성 값을 문자열 형태로 가져옵니다.

const targetClass = ...
가져온 class 이름을 targetClass 변수에 저장합니다.

사용자가 클릭한 요소의 클래스 이름을 가져와서 targetClass 라는 변수에 담아라.


HTML

<li data-id="1">
    <button class ="toggle-btn">완료</button>
    <button class ="delete-btn">삭제</button>
<li>


사용자가 "삭제" 버튼을 클릭했다면
event.target.className; //"delete-btn"

사용자가 "완료" 버튼을 클릭했다면
event.target.className; //"toggle-btn"

즉, 이 줄은 *** 지금 클릭된 버튼이 토글 버튼인지, 삭제 버튼인지 구분하기 위해 class 이름을 확인하는 단계***  입니다



if( targetClass === 'toggle-btn') {
}

if
조건문
안의 조건이 참(true) 일 때만 {...} 안의 코드 실행

targetClass
바로 전에 가져온 "클릭된 요소의 클래스 이름" (문자열)

=== 'toggle-btn'
targetClass 값이 "toggle-btn" 과 완전히 같을 때 (자료형 까지 일치)만 참(true)


쉽게 말하면
"지금 클릭된 버튼의 클래스가 toggle-btn"이면 아래 코드를 실행해라

예시 상황
HTML

<li data-id="1">
    <button class="toggle-btn">완료</button>
    <button class="delete-btn">삭제</button>
</li>


"완료" 버튼 클릭 시
event.target.className
->
"toggle-btn"
조건문 참 -> 실행 o

"삭제" 버튼 클릭 시
event.target.className
->
"delete-btn"
조건문 거짓 -> 실행 x


if(targetClass === 'toggle-btn') {
즉, 이 조건문은 클릭한 버튼이 완료 상태를 토클하는 버튼인지 확인하는 단계입니다.


toggleTodo(id)

toggleTodo
미리 정의된 함수 이름
(보통 특정 id를 가진 할 일 (todd)의 상태를 "완료 <-> 미완료"로 바꿔주는 함수입니다.)

(id)
앞에서 가져온 todo 항목의 고유 번호(data-id)를 인자로 전달합니다.
쉽게 말하면
이todo 의 고유번호(id) 를 넘겨서, 해당 항목의 완료 상태를 반대로 바꿔라


예시 상황
html
<li data-id="1">책 읽기 <button class="toggle">완료</buton></li>


자바스크립트

toggleTodo(1);
// -> id가 1번인 "책 읽기" 항목의 상태를 변경
// 미완료 -> 완료 또는 완료 -> 미완료


즉, 이 줄은 클릭한 버튼이 toggle-btn 일 경우, 해당 할 일을 완료/취소 상태로 바꿔주는 역할을 한다



else if (targetClass === 'delete-btn'){
}

else if
앞의 if 조건이 거짓일 때,
다른 조건을 검사하는 구문

targetClass === 'delete-btn'
클릭된 요소의 클래스이름(targetClass)이  "delete-btn"과 완전히 같은지 비교

{...}
조건이 참일 경우 실행할 코드 블록


} else if (targetClass === 'delete-btn') {
쉽게 말하면
앞에서 toggle-btn 이 아니라면, 이번엔 delete-btn 인지 확인해서 맞으면 {...} 안의 코드를 실행하라



html

<li data-id="2">
    <span> 청소하기 </span>
    <button class="toggle-btn"> 완료 </button>
    <button class="delete-btn"> 삭제 </button>
</li>

1. "완료"버튼 클릭 시 -> if(targetClass === 'toggle-btn') 실행
2. "삭제"버튼 클릭 시-> else if(targetClass === 'delete-btn') 실행


즉 이 줄은 ***클릭한 버튼이 삭제 버튼인지 확인하는 단계 *** 입니다.





// 할 일 목록의 버튼 클릭 이벤트를 처리하는 코드 (이벤트 위임 방식 사용)
todoList.addEventListener('click', (event) => {
    // 클릭된 요소(event.target)를 기준으로 가장 가까운 <li> 요소를 찾음
    // -> 할 일 (todo) 하나를 감싸는 li 태그
    const li = event.target.closest('li');
    if(!li) return; // li 가 없으면 (즉, 리스트 영역이 아닌 곳을 클릭했다면) 아무 동작 안 함

    // 해당 li에 저장된 dataset.id 값을 가져와 숫자로 변환
    // (dataset.id는 HTML에서 <li data-id="1"> 같은 속성으로 지정됨)
    const targetClass = event.target.className;

    // 완료/미완료 상태를 토글하는 버튼(toggle-btn) 클릭 시
    if (targetClass === 'toggle-btn') {
        toggleTodo(id); // 해당 id의 할 일 상태를 변경하는 함수 호출
    }
    // 삭제 버튼(delete-btn) 클릭 시
    else if (targetClass === 'delete-btn') {
        // 삭제 확인 창 띄우기
        if (confirm("정말로 삭제하시겠습니까?")) {
            deleteTodo(id);     // 확인 누르면 해당id의 할 일 삭제
        }
    }
});


해설
이벤트 위임 (Event Delegation)
개별 버튼에 직접 이벤트를 달지 않고, 상위요소 (todoList)에 이벤트를 한 번만 등록해서
효율적으로 관리
클릭된 요소(event.target)가 어떤 버튼인지 확인해 동작 분기

closest('li')
클릭된 요소에서 가장 가까운<li>를 찾음 -> 클릭한 버튼이 속한 "할 일 항목"을 특정

dataset.id
HTML 속성 <li data-id="3">에 저장된 id 값ㅇ르 가져와서 할 일을 식별

toggleTodo / deleteTodo
toggleTodo(id)
해당 할 일의 완료 여부를 변경
deleteTodo(id)
해당 할 일을 삭제




function initialize() {...}

function : 자바스크립트에서 함수를 선언할 때 쓰는 키워드
initialize : 함수 이름인데, "초기화하다" 라는 뜻을 가진 영어단어
{...} : 함수 안에서 실행될 코드를 담는 블록(중괄호)

->
"initialize 라는 이름의 함수를 정의한다. 이 함수 안에는 초기 설정이나 시작할 때 실행할 코드가 들어간다"

보통 initialize() 함수는
웹페이지가 처음 로드될 때,
프로그램을 실행할 때,
특정 기능을 시작하기 전에 필요한 값들을 세팅하거나 이벤트를 등록할 때

자주 사용된다.



setActiveFilter(showAllBtn);    // '모두' 버튼을 기본 활성 상태로 설정

setActiveFilter
현재 활성화된 필터 버튼을 지정하는 함수 (앞에서 지정되어 있음)

showAllBtn
전체 보기 버튼(모두 버튼) 을 가리키는 변수
(HTML 의 '모두' 버튼 요소를 담고 있음)

setActiveFilter(showAllBtn);
setActiveFilter 함수에 '모두 버튼'을 넘겨서 기본으로 활성화시킨다.

즉
->
초기 실행 시, '모두' 버튼이 선택된 것처럼 표시되도록 활성화한다


fetchTodos();
Todos(할 일 목록)을 서버나 저장소에서 가져오는 함수
즉, "할 일 리스트 데이터를 불러오는 역할"을 담당

최종 해석
"앱이 실행되면 fetchTodos()" 함수를 호출해서 전체 할 일 목록을 불러온다.


initialize(); 실행
단순히 함수 정의만 해두면 동작하지 않으므로, 마지막에 호출해서 페이지가 로드 되자마자 실행되도록 만든 것






CSS 코드에 대한 해설
CSS 변수를 활용하여 재사용성과 유지보수성을 높인 투두 리스트 애플리케이션의 스타일.

1. CSS 변수 선언  ( :root )
전역적으로 사용할 색상, 폰트, 레이아웃 관련 값을 정의합니다.

2. 기본 및 레이아웃 스타일 (body, .container )
페이지 전체의 기본 스타일과 컨테이너의 중앙 정렬 및 디자인을 설정합니다.

3. 입력 및 필터 영역
투두를 추가하고 필터링하는 부분의 스타일을 담당합니다.

4. 공통 버튼 스타일
모든 버튼에 적용되는 기본 스타일과 각 버튼의 고유한 스타일을 정의합니다.

5. 투두 리스트 아이템
개별 투두 아이템의 디자인과 완료 상태에 따른 시각적 변화를 처리합니다.



/**
CSS 변수 선언 (테마 및 기본값 관리)

모든 스타일의 기본이 되는 변수들을 선언합니다.
이 변수들을 사용하면 스타일을 일괄적으로 변경하기 용이하며,
코드의 가독성과 유지보수성이 크게 향상됩니다.
**/
:root {

}

:root
CSS의 :root는 HTML 문서의 최상위 요소(루트 요소)를 의미

구체적으로 설명하면
웹 문서의 루트 요소는 <html> 태그이다.

따라서
:root 는 사실상 html 과 같지만, CSS 변수(커스텀 프로퍼티)를 선언할 때는 보통 :root를 사용합니다.

이렇게 하면 페이지 전체 어디서든 그 변수를 불러다 쓸 수 있습니다.

예시
css

:root {
    --main-color: blue;     /* CSS 변수 정의 */
    --font-size: 16px;
}

body {
    color: var(--main-color);       /* 변수 사용*/
    font-size: var(--font-size);
}

위 코드에서
:root 안에 --main-color 와 --font-size를 정의했다.
이후 body 같은 다른 CSS 선택자에서 var(--변수명)으로 불러다 쓰는 것이다.

정리
:root = HTML 전체에 적용되는 최상위 선택자
특히 CSS 변수를 전역(Global)으로 선언할 때 가장 많이 사용



body {
}

CSS에서 body {...} 라고 쓰면 HTML 문서의 <body> 태그를 선택한다는 뜻

정리
body: HTML 문서에서 눈에 보이는 실제 내용(content)을 담는 가장 큰 영역

html

<html>
    <head> ... </head>
    <body>
        <h1>제목</h1>
        <p>내용</p>
    </body>
</html>

여기서 body 선택자는 <body> 태그에 CSS스타일을 적용한다는 의미

즉, body {...} 는
웹페이지 전체의 기본 스타일을 지정하겠다   라는 뜻




.container {...}
CSS에서 class="container" 라고 지정된 HTML 요소에 스타일을 적용한다는 뜻


예시

html

<div class="container">
    <h1>할 일 목록</h1>
    <p>이곳이 메인 박스입니다.</p>
</div>

위 HTML에서 <div class="container">...</div> 부분이 있으면,
CSS의 .container {...} 규칙이 이 <div>에 적용됩니다.


정리하면
contaier = 클래스 이름
.container = 그 클래스를 가진 요소 선택자
즉, "메인 콘텐츠 박스를 꾸미겠다" 라는 의미



CSS에서 h1{...} 라고 쓰면

HTML 문서 안의 <h1> 태그(가장 큰 제목 요소)에 스타일을 적용하겠다는 뜻

<h1> 투두 리스트 </h1>
<p> 오늘 할 일을 정리해 보세요! </p>

css

h1 {
    text-align: center; /* 가운데 정렬 */
    color: red;         /* 빨간색 글씨 */
    font-size: 30px;    /* 글씨 크기 30px */
}


정리하면
h1 = HTML의 제목 태그(Heading 1, 가장 큰 제목)
h1 {...} = 그 제목 태그 전체에 적용할 CSS 스타일을 지정



CSS에서 .input-container {...} 라고 쓰면

class="input-container" 라고 붙어있는 HTML 요소에 스타일을 적용한다는 뜻



html

<div class="input-container">
    <input type="text" placeholder="할 일을 입력하세요">
    <button>추가</button>
</div>

css

.input-container {
    display : flex;         /* 내부 요소(input, button)를 가로로 배치 */
    gap: 10px;              /* input과 버튼 사이 간격 */
    margin-bottom: 20px;    /* 아래쪽 여백 */
}

입력창과 버튼이 같은 줄에 나란히 배치됨

정리하면

.input-container = 클래스 선택자
주로 입력창과 버튼을 담는 박스를 꾸밀  때 사용

input[type="text"] {...} CSS 속성 선택자

즉, HTML 에서 <input> 태그 중 type="text" 속성을 가진 것만 골라서 스타일을 적용한다는 뜻

html

<input type="text" placeholder="이름을 입력하세요">
<input type="password" placeholder = "비밀번호 입력">
<input type="checkbox"> 동의합니다

css

input[type="text"] {
    width: 200px;    /* 가로 길이 200px */
    padding: 8px;    /* 안쪽 여백 */
    border: 2px solid blue; /* 파란색 테두리 */
    border-radius: 5px;     /* 모서리 둥글게 */
}

정리하면
input[type="text"] = <input> 중에서 텍스트 입력칸만 선택
특정 타입의 입력창만 꾸밀때 자주 쓰는 방법



.edit-input {...} 클래스는 선택자이다
즉, HTML 에서 class="edit-input" 이라고 붙어 있는 요소에만 스타일을 적용한다는 뜻

<li>
    <span> 할 일 내용 </span>
    <input type="text" class="edit-input value="수정 중인 내용">
</li>



css
.edit-input {
    width:100%;     /* 가로 전체 차지*/
    padding: 8px;   /* 안쪽 여백*/
    border: 1px solid gray;     /** 모서리 둥글게 */
    font-sized: 16xpx;          /* 글자 크기 */

}

결과 느낌
보통 수정모드에서만 나타나는 입력창을 꾸밀 때 사용
평소에는 <span>으로 할 일을 보여주다가 수정 버튼을 누르면 <input class="edit-input">이 나타남

.edit-input = 수정 전용 입력칸을 위한 CSS 클래스
깔끔하게 보이도록 크기, 여백, 테두리 등을 따로 지정



.filter-container {
}

.filter-container 는 CSS 클래스 선택자입니다.

즉, HTML에서 class ="filter-container"를 가진 요소에 이 안의 CSS 스타일을 적용하겠다는 뜻

예시

html

<div class="filter-container>
    <button>전체</button>
    <button>완료</button>
    <button>미완료</button>
</div>

위와 같이 <div>가 filter-container 라는 클래스를 가지고 있으면,
CSS의 .filter-container {...} 안에 정의된 스타일이적용됨


button {...}

button은 HTML <button> 태그 전체를 선택하는 CSS 선택자

즉, 페이지 안에 있는 모든 버튼 요소에 해당 스타일을 적용하겠다는 뜻

button {
    padding: 8px 16px;      /* 버튼 안쪽 여백 */
    border: none;           /* 테두리 제거 */
    border-radius: 6px;     /* 모서리를 둥글게 */
    background-color: #007BFF;  /* 파란색 배경 */
    color: white;               /* 글자색 흰색 */
    cursor: pointer;            /* 마우스 올리면 손가락 모양 */
}



html

<button>전체</button>
<button>완료</button>
<button>미완료</button>

결과
모든 버튼이 파란색 바탕, 흰 글씨, 둥근 모서리로 바뀜
버튼 위에 마우스를 올리면 솔가락 커서가 나타남

즉,
button{...}
프로젝트 안의 모든 버튼을 공통스타일로 꾸미는 부분입니다.




#add-button {...}

#add-button 은 CSS ID 선택자입니다.

즉, HTML 에서 id="add-button" 속성을 가진 단 하나의 요소에만 스타일을 적용하겠다라는 뜻


예시
html
<button id ="add-button">추가</button>


css
#add-button {
    padding: 10px 20px;         /* 버튼 안쪽 여백 */
    background-color: #28a745;  /* 초록색 배경 */
    color: white;               /* 글자 흰색 */
    border: none;               /* 테두리 제거 */
    border-radius: 8px;         /* 둥근 모서리 */
    cursor: pointer;            /* 마우스 올리면 손가락 모양 */
}


결과
<button id="add-button">추가</button> 이 버튼만 특별히 초록색으로 꾸며짐
다른 버튼들에는 영향을 주지 않음


.className {}
같은 클래스를 가진 여러 요소에 스타일 적용

#idName {}
해당 ID 하나짜리 요소에만 스타일 적용



# add-button:hover {
}

#add-button
id="add-button" 인 요소를 선택

:hover
마우스를 올렸을 때(hover 상태)적용되는 스타일

따라서 #add-button:hover {...} 는
추가 버튼 위에 마우스를 올리면 어떤 스타일로 변할지 정의하는 부분



예시
 css

 #add-button {
    padding: 10px 20px;
    background-color: #28a745;  /* 초록색 */
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.3s ease; /* 색 변화 부드럽게 *//
 }

 #add-button:hover {
    bakground-color: #218838;  /* 더 진한 초록색으로 변경 */

 }

 html
 <button id="add-button"> 추가 </button>

 평소에는 밝은 초록색 버튼
 마우스를 올리면 조금 더 진항 초록색을 바뀜 (누르고 싶어지는 효과)

.filter-container button {
}

.filter-container button {...}

.filter-container
->
class="filter-container" 를 가진 요소

button
그 안에 있는 모든 <button> 태그

즉,
filter-container 안에 들어 있는 버튼들만 골라서 스타일을 적용하겠다는 뜻

html

<div class="filter-container">
    <button>전체</button>
    <button>완료</button>
    <button>미완료</button>
</div>

<button>추가 버튼</button>      <!-- 이건 filter-container 밖에 있음>

css
.filter-container button {
    padding: 6px 12px;
    background-color: #f1f1f1;      /* 회색 배경 */
    border: 1px solid #ccc;         /* 연한 테두리 */
    border-radius: 6px;
    cursor: pointer;
}

결과
filter-container 안의 버튼(전체/완료/미완료) 만 스타일이 적용됨
바깥에 있는 "추가 버튼"은 이 규칙의 영향을 받지 않음

정리하면
.filter-container button {...}
필터 버튼들만 따로 꾸미기 위한 선택자






.filter-container button:hover:not(.active) {...}

해석
.filter-container
class="filter-container" 를 가진 영역 안에서

button
버튼 요소들 중에서

:hover
마우스를 올렷을 때

:not(.active)
단, active 클래스가 없는 버튼만

해석
.filter-container
->
class="filter-container"를 가진 영역 안에서


button
버튼 요소들 중에서

:hover
마우스를 올렸을 때

:not(.active)
->
단, active 클래스가 없는 버튼만

즉,
필터 버튼 중에서 현재 선택(active)되지 않은 버튼에 마우스를 올렸을 때 적용되는 스타일을 지정하는 코드



html

<div class="filter-container">
    <button class="active"> 전체 </button>
    <button> 완료 </button>
    <button> 미완료 </button>
</div>





css

.filter-container button {
    padding: 6px 12px;
    background-color: #f1f1f1;
    border: 1px solid #ccc;
    border-radius: 6px;
    cursor: pointer;
}

.filter-container button.active {
    background-color: #007bff;  /* 선택된 버튼은 파란색 */
    color: white;
}

.filter-container button:hover:not(.active) {
    background-color:#ddd;      /* 선택되지 않은 버튼만 hover 시 회색으로 변함 */
}

결과
"전체" 버튼은 active 상태라 파란색이고 hover 효과 안 먹음
"완료"/"미완료" 버튼은 hover 하면 회색으로 변함

정리하면
.filter-container button:hover:not(.active)
->
선택되지 않은 필터 버튼에만 hover 효과를 주는 조건부 스타일





.filter-container button.active {...}

이건 CSS 선택자이다 해석하면

.filter-container
->
클래스 이름이 filter-container 인 요소 안에서

button.active
active 라는 클래스를 가진 button 요소를 선택한다는 뜻

즉
"filter-container" 라는 컨테이너 안에 있는, active 클래스가 붙은 버튼에 스타일을 적용하라



.action-buttons button {
}

이것은 CSS 선택자이다


.action-buttons
class="action-buttons" 라는 클래스를 가진 요소를 선택함

button
그 안에 포함된 <button> 태그만 선택함

{...}
선택된 버튼에 적용할 스타일을 정의하는 영역

즉,
class="action-buttons" 안에 있는 버튼들에게만 스타일을 적용하겠다  라는 뜻


예시

html

<div class="action-buttons">
    <button>저장</button>
    <button>삭제</button>
</div>


css

.action-buttons button {
    color: white;
    background-color: blue;
    border-radius: 5px;
}

이렇게 하면 위 div 안의 버튼들만 파란색 배경, 흰색 글씨, 둥근 모서리 스타일이 적용된다.



.action-buttons .toggle-btn, .action-buttons .delete-btn {
}

.action-buttons .toggle-btn, .action-buttons .delete-btn {...}


이 CSS 선택자의 의미는 다음과 같다

1.
.action-buttons . toggle-btn
class="action-buttons" 안에 있는 요소 중
class="toggle-btn"을 가진 요소를 선택

2.
.action-buttons .delete-btn
class="action-buttons" 안에 있는 요소 중
class="delete-btn"을 가진 요소를 선택


,(쉼표)
두 선택자를 동시에 묶어서 같은 스타일을 적용하겠다는 뜻

즉,

.action-buttons 컨테이너 안의 토글 버튼( .toggle-btn ) 과 삭제 버튼 ( .delete-btn )에 같은 CSS 스타일을 준다는 의미



예시코드

html

<div class="action-buttons">
    <button class="toggle-btn"> 완료/취소 </button>
    <button class="delete-btn"> 삭제 </button>
</div>


css

.action-buttons .toggle-btn
.action-buttons .delete-btn
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

이렇게 하면 toggle-btn 과 delete-btn 두 버튼에 모두 동일한 스타일이 적용됩니다.




.action-buttons .toggle-btn,
.action-buttons .delete-btn {
  padding: 8px 12px;    // padding = 안쪽 여백 -> 버튼 안의 글자와 테두리 사이 간격
                        // (위아래 8px, 좌우 12px)

  border: none;         // border = 테두리 -> 버튼의 기본 테두리를 없앰
  border-radius: 5px;   // border-radius = 모서리를 둥글게 -> 버튼의 네 모서리를 5px 만큼 둥글게 만듦
                        // radius(반지름)라는 뜻 -> 둥글기의 정도

  cursor: pointer;      // cursor = 마우스 커서 -> 버튼 위에 마우스를 올렸을 때
                        // pointer = 손가락 모양(클릭 가능한 링크/버튼처럼 표시)

}

단어 정리
padding (패딩) -> "안쪽 여백" (내용과 테두리 사이 공간)
border (보더) -> "테두리"
border-radius(보더 레이디우스) -> "둥근 테두리 모서리"
radius (레이디우스) -> "반지름" (원의 반지름 -> 둥글기의 정도를 나타낼 때 씀)
cursor (커서) -> "마우스 포인터 모양"
pointer (포인터) -> "손가락 모양 커서 (클릭 가능한 상태 표시)"





css

.action-buttons .toggle-btn {
    color: var(--color-success);
}



.action-buttons .toggle-btn
class="action-buttons" 안에 있는
class="toggle-btn" 요소에만 적용

color
글자색(텍스트 색상)을 지정하는 속성

var(--color-success)
CSS 변수(variable)를 사용한 것
--color-success 라는 이름의 CSS 변수를 불러와서 색상 값으로 사용
예를 들어
:root { --color-success: green; } 라고 정의돼 있으면, 글자 색이 초록색이 됨

쉽게 풀면
.action-buttons 안에 있는 toggle-btn의 글자색을, 미리 지정된 성공 색상(예: 초록색)으로 바꾼다.





css

.action-buttons .toggle-btn:hover {
    color: var(--color-success-dark);
}

.action-buttons .toggle-btn:hover
class="action-buttons" 안에 있는
class="toggle-btn" 요소에 적용되는데
:hover -> 마우스가 버튼 위에 올라갔을 때만 실행


color
글자 색상(텍스트 색상)을 지정

var(--color-success-dark)
    CSS 변수 --color-success-dark 값을 가져와서 적용

예: :root {--color-success-dark: darkgreen;} 이라고 정의되어 있다면 마우스를 올리면 글자색이 진한 초록색으로 변함


쉽게 풀면
토글 버튼에 마우스를 올렸을 때, 글자 색상을 "성공색(진한 버전)"으로 바꾼다



.action-buttons .delete-btn {
    color: var(--color-danger);
}


해석
.action-buttons .delete-btn

class="action-buttons" 요소 안에 있는
class="delete-btn" 요소에 스타일 적용

color
글자 색(텍스트 색상)을 지정

var(--color-danger)
    CSS 변수 --color-danger 값을 불러와서 적용


css

:root {
    --color-danger: red;
}

쉽게 풀면
액션 버튼 영역 안에 있는 삭제 버튼(delete-btn)의 글자색을 위험(빨간색) 색상으로 지정한다




css

.action-buttons .delete-btn:hover {
}


1.
action-buttons .delete-btn:hover
class="action-buttons" 안에 있는
class="delete-btn" 요소에 적용되는데
:hover -> 마우스를 올렸을 때만 실행

2.
color
글자 색상(텍스트 색)을 지정

3.
var(--color-danger-dark)

CSS 변수 --color-danger-dark 값을 불러와 적용
보통 빨간색 계열의 진한 톤으로 정의됨


예

css

:root {
    --color-danger: red;
    --color-danger-dark: darkred;
}

쉽게 풀면
삭제 버튼 글자가 평소에는 빨간색(--color-danger)인데, 마우스를 올리면 더 진한 빨간색(--color-danger-dark)으로 변한다







css

.action-buttons .edit-btn,
.action-buttons .save-btn,
.action-buttons .cancel-btn {
    /* 여기에 스타일 정의 */
}

1.
.action-buttons .edit-btn
class="action-buttons" 안에 있는
class="edit-btn" 요소에 적용

2.
.action-buttons .save-btn
class="action-buttons" 안에 있는
class="save-btn" 요소에 적용

3.
.action-buttons .cancel-btn
같은 방식으로 class="cancel-btn" 요소에 적용

4.
, (쉼표)
여러 선택자를 동시에 묶어서 같은 스타일을 적용하겠다는 뜻

쉽게 풀면
액션 버튼 영역 안에 있는

수정 버튼(edit-btn)
저장 버튼(save-btn)
취소 버튼(cancel-btn)
모두에게 동일한 CSS 스타일을 적용한다


예시

html

<div class="action-buttons">
    <button class="edit-btn">수정</button>
    <button class="save-btn">저장</button>
    <button class="cancel-btn>취소</button>
</div>


css

.action-buttons .edit-btn,
.action-buttons .save-btn,
.action-buttons .cancel-btn {
    padding: 6px 10px;
    border-radious: 5px;
    cursor: pointer;
}

이렇게 하면
수정/ 저장/ 취소 버튼이 모두 같은 디자인을 가지게 된다




#todo-list {
}

CSS에서 #todo-list 는 id가 todo-list인 요소를 선택합니다.


html

<ul id="todo-list">  ...   </ul>

처럼 id="todo-list" 가 붙은 <ul> 요소(또는 다른 태그)가 이 규칙의 대상이 됩니다.

현재 코드에서는   투두 리스트 전체 영역(ul)의 기본 스타일을 지정하는 부분입니다.


여기서는

css

#todo-list {
    list-style-type: none;      /* 기본 불릿(동그라미 기호, 네모 기호 등) 제거 */
    padding: 0;                 /* 내부 여백 제거 */
}

정리하면, 투두 리스트 항목들이 들어가는 리스트(ul)를 불릿 없이 깔끔하게 보이도록 만드는 스타일





#todo-list li {...}

id가 todo-list인 요소 안에 있는 모든 <li> 태그를 선택합니다.

즉, 아래처럼 구조가 있다면

html

<ul id="todo-list>
    <li>할 일1</li>
    <li>할 일2</li>
</ul>


이 <li> 들에 스타일이 적용돼요


코드에서 적용된 스타일은

css

#todo-list li {
    display: flex;                              /* 아이템을 가로로 배치 */
    align-items: center;                        /* 세로 가운데 정렬 */
    justify-content: space-between;             /* 좌우 끝으로 배치 (할 일 텍스트 <-> 버튼)
    padding: 15px;                              /* 내부 여백 */
    background-color: var(--color-bg-items);    /* 배경색 */
    border: 1px solid #eee;                     /* 테두리 */
}


정리하면
투두리스트의 각 아이템(개별 <li>을 카드 형태로 꾸며서)
텍스트와 버튼이 한 줄에 배치되고,
여백과 그림자 효과로 보기 좋게 정리되도록 만든 스타일입니다.



#todo-list li.completed {
}

이 선택자는

id="todo-list" 안에 있는
<li> 태그 중에서
class="completed" 가 추가된 요소
에만 적용됩니다.


예시
html

<ul id="todo-list">
    <li>할 일 1</li>
    <li class="completed">할 일 2 (완료됨) </li>
</ul>

해당 <li> 에는 다음 스타일이 적용됩니다.

css

#todo-list li.completed {
    background-color: var(--color-bg-item-completed);   /* 완료된 항목만 배경색 변경 */
}

정리하면
완료된 투두 항목을 시각적으로 구분하기 위해 배경색을 다르게 표시하는 스타일
즉, "완료됨" 표시를 배경색으로 알려줍니다



.todo-text{...}

CSS에서 .todo-text 는 class 이름이 todo-text인 요소를 선택합니다.

html

<li>
    <span class="todo-text">할 일 내용 </span>
</li>


코드에서 적용된 스타일은

css

.todo-text {

}




.todo-text.completed-text {
이건 클래스가 선택자 두 개를 동시에 만족하는 요소를 의미합니다.

즉,

class="todo-text" 이면서
class="completed-text" 도 함께 가진 요소

예시

html

<span class="todo-text completed-text> 완료된 할 일 </span>


코드에서 적용된 스타일은

css

.todo-text.completed-text {
    text-decoration: line-through;      /* 취소선 표시 */
    color: var(--color-text-muted);     /* 흐린 회색 글씨 */
}

정리하면

투두 텍스트가 완료된 상태일 때
글씨에 취소선을 긋고
색을 연하게 바꿔서
"끝난 작업임을" 시각적으로 보여주는 스타일




.action-buttons {
}

CSS에서 .action-buttons 는 class 이름이 action-buttons 인 요소를 선택합니다.

예시

html

<li>
    <span class="todo-text"> 할 일 내용 </span>
    <div class="action-buttons">
        <button class="toggle-btn"> 체크표시 </button>
        <button class="delete-btn"> 엑스표시 </button>
    </div>
</li>


코드에서 적용된 스타일은

css

.action-buttons {
    display: flex;  /* 내부 버튼들을 가로로 배치 */
    gap: 8px;       /* 버튼 사이 간격 */
}



정리하면,
->
투두 리스트 아이템 옆에 있는 버튼 모음(예:완료, 삭제, 수정 버튼 등)을 가로로 나란히 정렬하고 일정한 간격을 주는 스타일
즉, 버튼들이 뭉치지 않고 깔끔하게 배열되도록 해주는 역할을 합니다.
